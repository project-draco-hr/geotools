{
  if (s1 instanceof Reject) {
    return s2;
  }
 else   if (s2 instanceof Reject) {
    return s1;
  }
  if (s1 instanceof Accept || s2 instanceof Accept) {
    return ACCEPT;
  }
  List<Selector> selectors=new ArrayList<>();
  flatten(selectors,s1,Or.class);
  flatten(selectors,s2,Or.class);
  Map<Class,List<Selector>> classifieds=mapByClass(selectors);
  if (classifieds.get(Accept.class) != null) {
    return ACCEPT;
  }
  classifieds.remove(Reject.class);
  List<Class<? extends Selector>> classes=Arrays.asList(Data.class,Id.class,ScaleRange.class);
  for (  Class<? extends Selector> clazz : classes) {
    List<Selector> classSelectors=classifieds.get(clazz);
    if (classSelectors == null) {
      continue;
    }
    if (classSelectors.size() > 1) {
      try {
        Method combineAnd=clazz.getDeclaredMethod("combineOr",List.class);
        Selector result=(Selector)combineAnd.invoke(null,classSelectors);
        if (result == REJECT) {
          classifieds.remove(clazz);
        }
 else         if (result == ACCEPT) {
          return ACCEPT;
        }
 else         if (result instanceof Or) {
          classifieds.put(clazz,((Composite)result).children);
        }
 else {
          classifieds.put(clazz,Collections.singletonList(result));
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
  }
  List<Selector> finalList=new ArrayList<>();
  for (  List<Selector> list : classifieds.values()) {
    finalList.addAll(list);
  }
  if (finalList.size() == 0) {
    return REJECT;
  }
 else   if (finalList.size() == 1) {
    return finalList.get(0);
  }
 else {
    return new Or(finalList);
  }
}
