{
  FIDMapper mapper=wrapped.getFIDMapper(typeName);
  if (!checkSupportedMapper(mapper)) {
    if (mapper instanceof TypedFIDMapper)     mapper=((TypedFIDMapper)mapper).getWrappedMapper();
    throw new IOException("This feature type (" + typeName + ") is associated to "+ "an unsupported fid mapper: "+ mapper.getClass()+ "\n"+ "The supported fid mapper classes are: "+ Arrays.asList(SUPPORTED_FID_MAPPERS));
  }
  if (message == null)   message="Version enabling " + typeName;
  Connection conn=null;
  Statement st=null;
  ResultSet rs=null;
  PostgisSQLBuilder sqlb=wrapped.createSQLBuilder();
  Transaction t=new DefaultTransaction();
  t.putProperty(VersioningDataStore.AUTHOR,author);
  t.putProperty(VersioningDataStore.MESSAGE,message);
  try {
    VersionedJdbcTransactionState state=wrapped.getVersionedJdbcTransactionState(t);
    state.setTypeNameDirty(typeName);
    long revision=state.getRevision();
    Envelope envelope=wrapped.getFeatureSource(typeName).getBounds();
    if (envelope != null) {
      final GeometryDescriptor defaultGeometry=wrapped.getSchema(typeName).getGeometryDescriptor();
      if (defaultGeometry != null) {
        CoordinateReferenceSystem crs=defaultGeometry.getCoordinateReferenceSystem();
        if (crs != null)         envelope=JTS.toGeographic(envelope,crs);
        state.expandDirtyBounds(envelope);
      }
    }
    conn=state.getConnection();
    PkDescriptor pk=getPrimaryKeyConstraintName(conn,typeName);
    if (pk == null)     throw new DataSourceException("Cannot version tables without primary keys");
    String colList="";
    for (int i=0; i < pk.columns.length; i++) {
      colList+="," + pk.columns[i];
    }
    st=conn.createStatement();
    execute(st,"ALTER TABLE " + sqlb.encodeTableName(typeName) + " DROP CONSTRAINT "+ pk.name);
    execute(st,"ALTER TABLE " + sqlb.encodeTableName(typeName) + " ADD COLUMN REVISION BIGINT REFERENCES "+ TBL_CHANGESETS);
    execute(st,"ALTER TABLE " + sqlb.encodeTableName(typeName) + " ADD COLUMN EXPIRED BIGINT NOT NULL DEFAULT "+ Long.MAX_VALUE);
    execute(st,"ALTER TABLE " + sqlb.encodeTableName(typeName) + " ADD COLUMN CREATED BIGINT REFERENCES "+ TBL_CHANGESETS);
    execute(st,"UPDATE " + sqlb.encodeTableName(typeName) + " SET REVISION = "+ revision+ " , CREATED = "+ revision);
    execute(st,"ALTER TABLE " + sqlb.encodeTableName(typeName) + " ALTER REVISION SET NOT NULL");
    execute(st,"ALTER TABLE " + sqlb.encodeTableName(typeName) + " ALTER CREATED SET NOT NULL");
    execute(st,"ALTER TABLE " + sqlb.encodeTableName(typeName) + " ADD CONSTRAINT "+ pk.name+ " PRIMARY KEY(REVISION "+ colList+ ")");
    execute(st,"CREATE INDEX " + typeName.toUpperCase() + "_REVIDX"+ " ON "+ typeName+ "(EXPIRED"+ colList+ ")");
    rs=executeQuery(st,"SELECT VERSIONED from " + sqlb.encodeTableName(TBL_VERSIONEDTABLES) + " WHERE SCHEMA = '"+ getConfig().getDatabaseSchemaName()+ "'"+ " AND NAME='"+ typeName+ "'");
    if (rs.next()) {
      execute(st,"UPDATE " + sqlb.encodeTableName(TBL_VERSIONEDTABLES) + " SET VERSIONED = TRUE "+ " WHERE SCHEMA = '"+ getConfig().getDatabaseSchemaName()+ "'"+ " AND NAME='"+ typeName+ "'");
    }
 else {
      execute(st,"INSERT INTO " + sqlb.encodeTableName(TBL_VERSIONEDTABLES) + " VALUES(default, "+ "'"+ getConfig().getDatabaseSchemaName()+ "','"+ typeName+ "', TRUE)");
    }
    rs.close();
    createVersionedFeatureCollectionView(typeName,conn);
    t.commit();
    resetTypeInfo();
  }
 catch (  SQLException sql) {
    throw new DataSourceException("Error occurred during version enabling. " + "Does your table have columns with reserved names?",sql);
  }
catch (  TransformException e) {
    throw new DataSourceException("Error occurred while trying to compute the lat/lon bounding box " + "affected by this operation",e);
  }
 finally {
    JDBCUtils.close(rs);
    JDBCUtils.close(st);
    JDBCUtils.close(conn,t,null);
    t.close();
  }
}
