{
  x1=Math.toRadians(x1);
  y1=Math.toRadians(y1);
  x2=Math.toRadians(x2);
  y2=Math.toRadians(y2);
  final int MAX_ITERATIONS=100;
  final double EPS=0.5E-13;
  final double F=1 / getInverseFlattening();
  final double R=1 - F;
  double tu1=R * Math.sin(y1) / Math.cos(y1);
  double tu2=R * Math.sin(y2) / Math.cos(y2);
  double cu1=1 / Math.sqrt(tu1 * tu1 + 1);
  double cu2=1 / Math.sqrt(tu2 * tu2 + 1);
  double su1=cu1 * tu1;
  double s=cu1 * cu2;
  double baz=s * tu2;
  double faz=baz * tu1;
  double x=x2 - x1;
  for (int i=0; i < MAX_ITERATIONS; i++) {
    final double sx=Math.sin(x);
    final double cx=Math.cos(x);
    tu1=cu2 * sx;
    tu2=baz - su1 * cu2 * cx;
    final double sy=Math.hypot(tu1,tu2);
    final double cy=s * cx + faz;
    final double y=Math.atan2(sy,cy);
    final double SA=s * sx / sy;
    final double c2a=1 - SA * SA;
    double cz=faz + faz;
    if (c2a > 0) {
      cz=-cz / c2a + cy;
    }
    double e=cz * cz * 2 - 1;
    double c=((-3 * c2a + 4) * F + 4) * c2a * F / 16;
    double d=x;
    x=((e * cy * c + cz) * sy * c + y) * SA;
    x=(1 - c) * x * F + x2 - x1;
    if (Math.abs(d - x) <= EPS) {
      if (false) {
        faz=Math.atan2(tu1,tu2);
        baz=Math.atan2(cu1 * sx,baz * cx - su1 * cu2) + Math.PI;
      }
      x=Math.sqrt((1 / (R * R) - 1) * c2a + 1) + 1;
      x=(x - 2) / x;
      c=1 - x;
      c=(x * x / 4 + 1) / c;
      d=(0.375 * x * x - 1) * x;
      x=e * cy;
      s=1 - 2 * e;
      s=((((sy * sy * 4 - 3) * s * cz* d / 6 - x) * d / 4 + cz) * sy * d + y) * c * R* getSemiMajorAxis();
      return s;
    }
  }
  final double LEPS=1E-10;
  if (Math.abs(x1 - x2) <= LEPS && Math.abs(y1 - y2) <= LEPS) {
    return 0;
  }
  if (Math.abs(y1) <= LEPS && Math.abs(y2) <= LEPS) {
    return Math.abs(x1 - x2) * getSemiMajorAxis();
  }
  final CoordinateFormat format=new CoordinateFormat();
  throw new ArithmeticException(Errors.format(ErrorKeys.NO_CONVERGENCE_$2,format.format(new GeneralDirectPosition(Math.toDegrees(x1),Math.toDegrees(y1))),format.format(new GeneralDirectPosition(Math.toDegrees(x2),Math.toDegrees(y2)))));
}
