{
  try {
    final GRIB1ImageReader reader=(GRIB1ImageReader)GRIB1Driver.spi.createReaderInstance();
    reader.setInput(this.input);
    int numCoverages=0;
    final Name mainCoverageName=Utilities.buildCoverageName(input);
    Name coverageName=mainCoverageName;
    final int numImages=reader.getNumImages(false);
    Map<Name,Map<String,GRIB1ProductFieldType>> fieldsMap=new HashMap<Name,Map<String,GRIB1ProductFieldType>>();
    for (int imageIndex=0; imageIndex < numImages; imageIndex++) {
      final SpatioTemporalMetadata metadata=reader.getSpatioTemporalMetadata(imageIndex);
      final SliceDescriptor sd=reader.getSliceDescriptor(imageIndex);
      if (sd == null)       throw new IllegalStateException("unable to get the required sliceDescriptor");
      VerticalExtent ve=sd.getVerticalExtent();
      TemporalGeometricPrimitive time=sd.getTemporalExtent();
      CoordinateReferenceSystem crs=sd.getCoordinateReferenceSystem();
      String referenceID="";
      if (crs instanceof CompoundCRS) {
        List<CoordinateReferenceSystem> list=((CompoundCRS)crs).getCoordinateReferenceSystems();
        if (list != null && !list.isEmpty()) {
          for (          CoordinateReferenceSystem crsElement : list) {
            if (crsElement instanceof VerticalCRS) {
              referenceID=crsElement.getName().getCode();
              break;
            }
          }
        }
      }
      Band band=metadata.getBand(0);
      Set<TemporalGeometricPrimitive> temporalExtent;
      Set<NumberRange<Double>> verticalExtent;
      Map<String,GRIB1ProductFieldType> fields;
      if (!verticalCRSMap.containsKey(referenceID)) {
        coverageName=new NameImpl(mainCoverageName.getLocalPart() + "_" + Integer.toString(numCoverages++));
        coverageNames.add(coverageName);
        verticalCRSMap.put(referenceID,coverageName);
        temporalExtent=new LinkedHashSet<TemporalGeometricPrimitive>();
        verticalExtent=new LinkedHashSet<NumberRange<Double>>();
        fields=new LinkedHashMap<String,GRIB1ProductFieldType>();
        temporalExtentMap.put(coverageName,temporalExtent);
        verticalExtentMap.put(coverageName,verticalExtent);
        fieldsMap.put(coverageName,fields);
      }
 else {
        coverageName=verticalCRSMap.get(referenceID);
      }
      if (!envelopesMap.containsKey(coverageName)) {
        initOriginalEnvelopeAndCRS(coverageName,sd);
        final GridGeometry2D gridGeometry2D=buildGridGeometry2D(coverageName,metadata);
        gridGeometry2DMap.put(coverageName,gridGeometry2D);
      }
 else {
        GeneralEnvelope envelope=envelopesMap.get(coverageName);
        envelope.add(sd.getGeneralEnvelope());
        envelopesMap.put(coverageName,envelope);
      }
      temporalExtent=(LinkedHashSet<TemporalGeometricPrimitive>)temporalExtentMap.get(coverageName);
      verticalExtent=(LinkedHashSet<NumberRange<Double>>)verticalExtentMap.get(coverageName);
      if (ve != null) {
        NumberRange<Double> verticalEnvelope=NumberRange.create(ve.getMinimumValue().doubleValue(),ve.getMaximumValue().doubleValue());
        if (!verticalExtent.contains(verticalEnvelope))         verticalExtent.add(verticalEnvelope);
      }
      if (time != null) {
        if (!temporalExtent.contains(time))         temporalExtent.add(time);
      }
      fields=(LinkedHashMap<String,GRIB1ProductFieldType>)fieldsMap.get(coverageName);
      String elementName=band.getName();
      if (!fields.containsKey(elementName)) {
        Product product=GRIB1ProductFieldType.getProduct(elementName);
        Unit unit=Unit.ONE;
        if (product != null) {
          unit=product.getUoM();
        }
 else {
          String uOm=band.getUoM();
          if (uOm == null)           unit=Unit.ONE.alternate(uOm);
 else           try {
            unit=Unit.valueOf(uOm);
          }
 catch (          IllegalArgumentException iae) {
            try {
              unit=Unit.ONE.alternate(uOm);
            }
 catch (            IllegalArgumentException iae2) {
              if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE,"Unable to parse the provided unit " + uOm,iae2);
              }
            }
catch (            UnsupportedOperationException uoe) {
              if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE,"Unable to parse the provided unit " + uOm,uoe);
              }
            }
          }
        }
        final Name nameImpl=new NameImpl(coverageName.getLocalPart(),elementName);
        final InternationalString description=new SimpleInternationalString(elementName);
        final GridSampleDimension gridBand=Utilities.buildBands(band,elementName,unit);
        final GRIB1ProductFieldType fd=new GRIB1ProductFieldType(nameImpl,description,gridBand);
        fields.put(elementName,fd);
      }
      sliceDescriptorsMap.put(imageIndex,sd);
      spatioTemporalMetadataMap.put(imageIndex,metadata);
    }
    for (    Name covName : verticalExtentMap.keySet()) {
      Set<NumberRange<Double>> verticalExtent=verticalExtentMap.get(covName);
      if (verticalExtent.size() == 0) {
        verticalExtent=Collections.emptySet();
        verticalExtentMap.put(covName,verticalExtent);
      }
      Set<TemporalGeometricPrimitive> temporalExtent=temporalExtentMap.get(covName);
      if (temporalExtent.size() == 0) {
        temporalExtent=Collections.emptySet();
        temporalExtentMap.put(covName,temporalExtent);
      }
      Map<String,GRIB1ProductFieldType> fields=(LinkedHashMap<String,GRIB1ProductFieldType>)fieldsMap.get(covName);
      if (fields != null && !fields.isEmpty()) {
        final Set<FieldType> fieldTypes=new LinkedHashSet<FieldType>(fields.size());
        final StringBuilder sb=new StringBuilder();
        for (        GRIB1ProductFieldType fd : fields.values()) {
          fieldTypes.add(fd);
          final InternationalString description=fd.getDescription();
          sb.append(description != null ? description.toString() + "," : "");
        }
        String description=sb.toString();
        int pos=-1;
        if (description.length() > 0 && (pos=description.lastIndexOf(",")) != -1) {
          description=description.substring(0,pos);
        }
        DefaultRangeType range=new DefaultRangeType(covName,new SimpleInternationalString(description),fieldTypes);
        rangeMap.put(covName,range);
      }
    }
    numberOfCoverages=numCoverages;
    reader.dispose();
  }
 catch (  IOException e) {
    this.numberOfCoverages=1;
  }
catch (  FactoryException fe) {
    this.numberOfCoverages=1;
  }
catch (  TransformException fe) {
    this.numberOfCoverages=1;
  }
}
