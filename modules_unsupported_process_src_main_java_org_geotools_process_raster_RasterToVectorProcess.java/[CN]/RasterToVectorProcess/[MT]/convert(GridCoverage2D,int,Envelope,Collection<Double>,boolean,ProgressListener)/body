{
  if (monitor == null) {
    monitor=new NullProgressListener();
  }
 else {
    monitor.started();
  }
  ReferencedEnvelope workingBounds=null;
  if (bounds == null) {
    workingBounds=new ReferencedEnvelope(cov.getEnvelope());
  }
 else {
    CoordinateReferenceSystem sourceCRS=bounds.getCoordinateReferenceSystem();
    CoordinateReferenceSystem targetCRS=cov.getCoordinateReferenceSystem();
    if (sourceCRS != null) {
      if (!CRS.equalsIgnoreMetadata(sourceCRS,targetCRS)) {
        throw new ProcessException("CRS of bounds must match that of the coverage");
      }
    }
    ReferencedEnvelope inputBounds=new ReferencedEnvelope(bounds);
    ReferencedEnvelope covBounds=new ReferencedEnvelope(cov.getEnvelope());
    workingBounds=new ReferencedEnvelope(covBounds.intersection(inputBounds),targetCRS);
    if (workingBounds == null || workingBounds.isEmpty()) {
      throw new ProcessException("Specified bounds lie wholly outside of coverage");
    }
  }
  try {
    monitor.setTask(new SimpleInternationalString("Initializing"));
    initialize(cov,workingBounds,new SubProgressListener(monitor,10));
    monitor.setTask(new SimpleInternationalString("Vectorizing"));
    vectorizeAndCollectBoundaries(band,outsideValues,insideEdges,new SubProgressListener(monitor,70));
    SimpleFeatureType schema=RasterToVectorFactory.getSchema(cov.getCoordinateReferenceSystem());
    monitor.setTask(new SimpleInternationalString("Creating polygon features"));
    SimpleFeatureCollection features=assembleFeatures(cov,band,insideEdges,schema,new SubProgressListener(monitor,20));
    return features;
  }
 catch (  Exception ex) {
    throw new ProcessException(ex);
  }
 finally {
    monitor.complete();
  }
}
