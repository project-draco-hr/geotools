{
  final int STARTING_OFFSET=STARTING_OFFSET(elemInfo,triplet);
  final int eTYPE=ETYPE(elemInfo,triplet);
  final int INTERPRETATION=INTERPRETATION(elemInfo,triplet);
  final int LENGTH=coords.size() * D(GTYPE);
  if (!(STARTING_OFFSET >= 1) || !(STARTING_OFFSET <= LENGTH))   throw new IllegalArgumentException("ELEM_INFO STARTING_OFFSET " + STARTING_OFFSET + " inconsistent with ORDINATES length "+ coords.size());
  if (!(eTYPE == ETYPE.POLYGON) && !(eTYPE == ETYPE.POLYGON_EXTERIOR) && !(eTYPE == ETYPE.POLYGON_INTERIOR)) {
    throw new IllegalArgumentException("ETYPE " + eTYPE + " inconsistent with expected POLYGON, POLYGON_EXTERIOR or POLYGON_INTERIOR");
  }
  if (!(INTERPRETATION == 1) && !(INTERPRETATION == 3)) {
    LOGGER.warning("Could not create LinearRing with INTERPRETATION " + INTERPRETATION + " - we can only support 1 for straight edges");
    return null;
  }
  LinearRing ring;
  if (INTERPRETATION == 1) {
    ring=gf.createLinearRing(subList(gf.getCoordinateSequenceFactory(),coords,GTYPE,elemInfo,triplet));
  }
 else   if (INTERPRETATION == 3) {
    CoordinateSequence ext=subList(gf.getCoordinateSequenceFactory(),coords,GTYPE,elemInfo,triplet);
    Coordinate min=ext.getCoordinate(0);
    Coordinate max=ext.getCoordinate(1);
    ring=gf.createLinearRing(new Coordinate[]{min,new Coordinate(max.x,min.y),max,new Coordinate(min.x,max.y),min});
  }
 else {
    throw new IllegalArgumentException("ELEM_INFO INTERPRETAION " + elemInfo[2] + " not supported"+ "for JTS Polygon Linear Rings."+ "ELEM_INFO INTERPRETAION 1 and 3 are supported");
  }
  ring.setSRID(SRID);
  return ring;
}
