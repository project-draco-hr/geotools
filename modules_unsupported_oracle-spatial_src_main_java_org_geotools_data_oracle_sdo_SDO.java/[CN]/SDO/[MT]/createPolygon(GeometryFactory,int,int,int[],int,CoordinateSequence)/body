{
  final int STARTING_OFFSET=STARTING_OFFSET(elemInfo,triplet);
  final int eTYPE=ETYPE(elemInfo,triplet);
  final int INTERPRETATION=INTERPRETATION(elemInfo,triplet);
  ensure("ELEM_INFO STARTING_OFFSET {1} must be in the range {0}..{1} of COORDINATES",1,STARTING_OFFSET,ordinateSize(coords,GTYPE));
  if (!(1 <= STARTING_OFFSET && STARTING_OFFSET <= ordinateSize(coords,GTYPE))) {
    throw new IllegalArgumentException("ELEM_INFO STARTING_OFFSET " + STARTING_OFFSET + "inconsistent with COORDINATES length "+ ordinateSize(coords,GTYPE));
  }
  ensure("ETYPE {0} must be expected POLYGON or POLYGON_EXTERIOR (one of {1})",eTYPE,new int[]{ETYPE.POLYGON,ETYPE.POLYGON_EXTERIOR});
  if (!(eTYPE == ETYPE.POLYGON) && !(eTYPE == ETYPE.POLYGON_EXTERIOR)) {
    throw new IllegalArgumentException("ETYPE " + eTYPE + " inconsistent with expected POLYGON or POLYGON_EXTERIOR");
  }
  if (!(INTERPRETATION == 1) && !(INTERPRETATION == 3)) {
    LOGGER.warning("Could not create JTS Polygon with INTERPRETATION " + INTERPRETATION + " - we can only support 1 for straight edges, and 3 for rectangle");
    return null;
  }
  LinearRing exteriorRing=createLinearRing(gf,GTYPE,SRID,elemInfo,triplet,coords);
  List rings=new LinkedList();
  int etype;
  HOLES:   for (int i=triplet + 1; (etype=ETYPE(elemInfo,i)) != -1; i++) {
    if (etype == ETYPE.POLYGON_INTERIOR) {
      rings.add(createLinearRing(gf,GTYPE,SRID,elemInfo,i,coords));
    }
 else     if (etype == ETYPE.POLYGON) {
      LinearRing ring=createLinearRing(gf,GTYPE,SRID,elemInfo,i,coords);
      if (clock.isCCW(ring.getCoordinates())) {
        rings.add(ring);
      }
 else {
        break HOLES;
      }
    }
 else {
      break HOLES;
    }
  }
  Polygon poly=gf.createPolygon(exteriorRing,toInteriorRingArray(rings));
  poly.setSRID(SRID);
  return poly;
}
