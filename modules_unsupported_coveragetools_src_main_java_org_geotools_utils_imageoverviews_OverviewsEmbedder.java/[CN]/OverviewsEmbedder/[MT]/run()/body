{
  if (sourcePath == null) {
    fireEvent("Provided sourcePath is null",0);
    return;
  }
  final File file=new File(sourcePath);
  final File[] files;
  int numFiles=1;
  StringBuilder message;
  if (!file.canRead() || !file.exists()) {
    fireEvent("Provided file " + file.getAbsolutePath() + " cannot be read or does not exist",0);
    return;
  }
  if (file.isDirectory()) {
    if (wildcardString == null) {
      fireEvent("Provided wildcardString is null",0);
      return;
    }
    final FileFilter fileFilter=new WildcardFileFilter(wildcardString);
    files=file.listFiles(fileFilter);
    numFiles=files.length;
    if (numFiles <= 0) {
      message=new StringBuilder("No files to process!");
      if (LOGGER.isLoggable(Level.FINE)) {
        LOGGER.fine(message.toString());
      }
      fireEvent(message.toString(),100);
    }
  }
 else   files=new File[]{file};
  if (files == null || files.length == 0) {
    fireEvent("Unable to find input files for the provided wildcard " + wildcardString + " and input path "+ sourcePath,0);
    return;
  }
  for (fileBeingProcessed=0; fileBeingProcessed < numFiles; fileBeingProcessed++) {
    message=new StringBuilder("Managing file  ").append(fileBeingProcessed).append(" of ").append(files[fileBeingProcessed]).append(" files");
    if (LOGGER.isLoggable(Level.FINE)) {
      LOGGER.fine(message.toString());
    }
    fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
    if (getStopThread()) {
      message=new StringBuilder("Stopping requested at file  ").append(fileBeingProcessed).append(" of ").append(numFiles).append(" files");
      if (LOGGER.isLoggable(Level.FINE)) {
        LOGGER.fine(message.toString());
      }
      fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
      return;
    }
    ImageInputStream stream=null;
    ImageWriter writer=null;
    ImageOutputStream streamOut=null;
    TileCache baseTC=null;
    RenderedOp currentImage=null;
    RenderedOp newImage=null;
    try {
      File localFile=files[fileBeingProcessed];
      stream=ImageIO.createImageInputStream(localFile);
      if (stream == null) {
        message=new StringBuilder("Unable to create an input stream for file").append(files[fileBeingProcessed]);
        if (LOGGER.isLoggable(Level.SEVERE)) {
          LOGGER.severe(message.toString());
        }
        fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
        break;
      }
      stream.mark();
      final Iterator<ImageReader> it=ImageIO.getImageReaders(stream);
      if (!it.hasNext()) {
        message=new StringBuilder("Unable to find a reader for file").append(files[fileBeingProcessed]);
        if (LOGGER.isLoggable(Level.SEVERE)) {
          LOGGER.severe(message.toString());
        }
        fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
        break;
      }
      final ImageReader reader=(ImageReader)it.next();
      stream.reset();
      stream.mark();
      if (!reader.getFormatName().toLowerCase().startsWith("tif")) {
        if (LOGGER.isLoggable(Level.INFO)) {
          LOGGER.info("Discarding input file " + files[fileBeingProcessed] + " since it is not a proper tif file.");
        }
        continue;
      }
      reader.setInput(stream);
      ImageLayout layout=null;
      int actualTileW=reader.getTileWidth(0);
      int actualTileH=reader.getTileHeight(0);
      if (!reader.isImageTiled(0) || (reader.isImageTiled(0) && (actualTileH != tileH && tileH != -1) || (actualTileW != tileW && tileW != -1))) {
        message=new StringBuilder("Retiling image  ").append(fileBeingProcessed);
        if (LOGGER.isLoggable(Level.FINE)) {
          LOGGER.fine(message.toString());
        }
        fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
        layout=Utils.createTiledLayout(tileW,tileH,0,0);
      }
      stream.reset();
      reader.reset();
      reader.dispose();
      if (external) {
        localFile=new File(localFile.getParent(),FilenameUtils.getBaseName(localFile.getAbsolutePath()) + ".tif.ovr");
      }
      streamOut=ImageIOExt.createImageOutputStream(null,localFile);
      if (streamOut == null) {
        message=new StringBuilder("Unable to acquire an ImageOutputStream for the file ").append(files[fileBeingProcessed].toString());
        if (LOGGER.isLoggable(Level.SEVERE)) {
          LOGGER.severe(message.toString());
        }
        fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
        break;
      }
      writer=TIFF_IMAGE_WRITER_SPI.createWriterInstance();
      writer.setOutput(streamOut);
      writer.addIIOWriteProgressListener(writeProgressListener);
      writer.addIIOWriteWarningListener(writeProgressListener);
      ImageWriteParam param=writer.getDefaultWriteParam();
      if (tileH != -1 & tileW != -1) {
        param.setTilingMode(ImageWriteParam.MODE_EXPLICIT);
        param.setTiling(tileW,tileH,0,0);
      }
 else {
        param.setTilingMode(ImageWriteParam.MODE_EXPLICIT);
        param.setTiling(actualTileW,actualTileH,0,0);
      }
      if (this.compressionScheme != null && !Double.isNaN(compressionRatio)) {
        param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        param.setCompressionType(compressionScheme);
        param.setCompressionQuality((float)this.compressionRatio);
      }
      if (this.getTileCacheSize() <= 0) {
        baseTC=JAI.getDefaultInstance().getTileCache();
      }
 else {
        final long tilecacheSize=super.getTileCacheSize();
        baseTC=JAI.createTileCache();
        baseTC.setMemoryCapacity(tilecacheSize);
        baseTC.setMemoryThreshold(0.75f);
      }
      final RenderingHints newHints=new RenderingHints(JAI.KEY_IMAGE_LAYOUT,layout);
      newHints.add(new RenderingHints(JAI.KEY_TILE_CACHE,baseTC));
      ParameterBlock pbjRead=new ParameterBlock();
      pbjRead.add(stream);
      pbjRead.add(Integer.valueOf(0));
      pbjRead.add(Boolean.FALSE);
      pbjRead.add(Boolean.FALSE);
      pbjRead.add(Boolean.FALSE);
      pbjRead.add(null);
      pbjRead.add(null);
      pbjRead.add(null);
      pbjRead.add(null);
      currentImage=JAI.create("ImageRead",pbjRead,newHints);
      message=new StringBuilder("Read original image  ").append(fileBeingProcessed);
      if (LOGGER.isLoggable(Level.FINE)) {
        LOGGER.fine(message.toString());
      }
      fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
      int i=0;
      for (overviewInProcess=0; overviewInProcess < numSteps; overviewInProcess++) {
        message=new StringBuilder("Subsampling step ").append(overviewInProcess).append(" of image  ").append(fileBeingProcessed);
        if (LOGGER.isLoggable(Level.FINE)) {
          LOGGER.fine(message.toString());
        }
        fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
        if (currentImage.getWidth() / downsampleStep <= 0 || currentImage.getHeight() / downsampleStep <= 0)         break;
        final SubsampleAlgorithm algorithm=SubsampleAlgorithm.valueOf(scaleAlgorithm);
switch (algorithm) {
case Average:
          newImage=Utils.scaleAverage(currentImage,baseTC,downsampleStep,borderExtender);
        break;
case Filtered:
      newImage=Utils.filteredSubsample(currentImage,baseTC,downsampleStep,lowPassFilter);
    break;
case Bilinear:
  newImage=Utils.subsample(currentImage,baseTC,new InterpolationBilinear(),downsampleStep,borderExtender);
break;
case Bicubic:
newImage=Utils.subsample(currentImage,baseTC,new InterpolationBicubic(2),downsampleStep,borderExtender);
break;
case Nearest:
newImage=Utils.subsample(currentImage,baseTC,new InterpolationNearest(),downsampleStep,borderExtender);
break;
default :
throw new IllegalArgumentException("Invalid scaling algorithm " + scaleAlgorithm);
}
IIOMetadata imageMetadata=null;
if (writer instanceof TIFFImageWriter) {
imageMetadata=writer.getDefaultImageMetadata(new ImageTypeSpecifier(newImage),param);
if (imageMetadata != null) ((TIFFImageMetadata)imageMetadata).addShortOrLongField(BaselineTIFFTagSet.TAG_NEW_SUBFILE_TYPE,BaselineTIFFTagSet.NEW_SUBFILE_TYPE_REDUCED_RESOLUTION);
}
if (!external || i > 0) writer.writeInsert(-1,new IIOImage(newImage,null,imageMetadata),param);
 else writer.write(null,new IIOImage(newImage,null,imageMetadata),param);
message=new StringBuilder("Step ").append(overviewInProcess).append(" of image  ").append(fileBeingProcessed).append(" done!");
if (LOGGER.isLoggable(Level.FINE)) {
LOGGER.fine(message.toString());
}
fireEvent(message.toString(),((fileBeingProcessed * 100.0) / numFiles));
baseTC.flush();
currentImage=newImage;
i++;
}
message=new StringBuilder("Done with  image  ").append(fileBeingProcessed);
if (LOGGER.isLoggable(Level.FINE)) {
LOGGER.fine(message.toString());
}
fireEvent(message.toString(),(((fileBeingProcessed + 1) * 100.0) / numFiles));
}
 catch (Throwable e) {
fireException(e);
}
 finally {
if (baseTC != null) try {
baseTC.flush();
}
 catch (Exception e) {
}
try {
if (streamOut != null) streamOut.flush();
}
 catch (Throwable e) {
if (LOGGER.isLoggable(Level.FINE)) LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
}
try {
if (streamOut != null) streamOut.close();
}
 catch (Throwable e) {
if (LOGGER.isLoggable(Level.FINE)) LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
}
try {
if (writer != null) writer.dispose();
}
 catch (Throwable e) {
if (LOGGER.isLoggable(Level.FINE)) LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
}
try {
if (currentImage != null) currentImage.dispose();
}
 catch (Throwable e) {
if (LOGGER.isLoggable(Level.FINE)) LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
}
try {
if (newImage != null) newImage.dispose();
}
 catch (Throwable e) {
if (LOGGER.isLoggable(Level.FINE)) LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
}
try {
if (stream != null) stream.close();
}
 catch (Throwable e) {
if (LOGGER.isLoggable(Level.FINE)) LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
}
}
}
if (LOGGER.isLoggable(Level.FINE)) LOGGER.fine("Done!!!");
}
