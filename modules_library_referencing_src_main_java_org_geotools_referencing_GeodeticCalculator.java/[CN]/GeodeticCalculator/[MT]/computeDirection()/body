{
  if (!destinationValid) {
    throw new IllegalStateException(Errors.format(ErrorKeys.DESTINATION_NOT_SET));
  }
  final double long1=this.long1;
  final double lat1=this.lat1;
  final double long2=this.long2;
  final double lat2=this.lat2;
  final double dlon=castToAngleRange(long2 - long1);
  final double ss=abs(dlon);
  if (ss < TOLERANCE_1) {
    distance=getMeridianArcLengthRadians(lat1,lat2);
    azimuth=(lat2 > lat1) ? 0.0 : PI;
    directionValid=true;
    antipodal=false;
    return;
  }
  antipodal=(PI - ss < 2 * TOLERANCE_3) && (abs(lat1 + lat2) < 2 * TOLERANCE_3);
  final double ESQP=eccentricitySquared / (1.0 - eccentricitySquared);
  final double alimit=PI * fo;
  if (ss >= alimit && lat1 < TOLERANCE_3 && lat1 > -TOLERANCE_3 && lat2 < TOLERANCE_3 && lat2 > -TOLERANCE_3) {
    final double CONS=(PI - ss) / (PI * f);
    double AZ=asin(CONS);
    double AZ_TEMP, S, AO;
    int iter=0;
    do {
      if (++iter > 8) {
        throw new ArithmeticException(getNoConvergenceErrorMessage());
      }
      S=cos(AZ);
      final double C2=S * S;
      AO=T1 + T2 * C2 + T4 * C2 * C2 + T6 * C2 * C2* C2;
      final double CS=CONS / AO;
      S=asin(CS);
      AZ_TEMP=AZ;
      AZ=S;
    }
 while (abs(S - AZ_TEMP) >= TOLERANCE_2);
    final double AZ1=(dlon < 0.0) ? 2.0 * PI - S : S;
    azimuth=castToAngleRange(AZ1);
    S=cos(AZ1);
    final double U2=ESQP * S * S;
    final double U4=U2 * U2;
    final double U6=U4 * U2;
    final double U8=U6 * U2;
    final double BO=1.0 + 0.25 * U2 + 0.046875 * U4 + 0.01953125 * U6 + -0.01068115234375 * U8;
    S=sin(AZ1);
    final double SMS=semiMajorAxis * PI * (1.0 - f * abs(S) * AO - BO * fo);
    distance=semiMajorAxis * ss - SMS;
    directionValid=true;
    return;
  }
  final double u1=atan(fo * sin(lat1) / cos(lat1));
  final double u2=atan(fo * sin(lat2) / cos(lat2));
  final double su1=sin(u1);
  final double cu1=cos(u1);
  final double su2=sin(u2);
  final double cu2=cos(u2);
  double xy, w, q2, q4, q6, r2, r3, sig, ssig, slon, clon, sinalf, ab=dlon;
  int kcount=0;
  do {
    if (++kcount > 12) {
      throw new ArithmeticException(getNoConvergenceErrorMessage());
    }
    clon=cos(ab);
    slon=sin(ab);
    final double csig=su1 * su2 + cu1 * cu2 * clon;
    ssig=hypot(slon * cu2,su2 * cu1 - su1 * cu2 * clon);
    sig=atan2(ssig,csig);
    sinalf=cu1 * cu2 * slon / ssig;
    w=(1.0 - sinalf * sinalf);
    final double t4=w * w;
    final double t6=w * t4;
    final double ao=f + a01 * w + a02 * t4 + a03 * t6;
    final double a2=a21 * w + a22 * t4 + a23 * t6;
    final double a4=a42 * t4 + a43 * t6;
    final double a6=a63 * t6;
    double qo=0.0;
    if (w > TOLERANCE_0) {
      qo=-2.0 * su1 * su2 / w;
    }
    q2=csig + qo;
    q4=2.0 * q2 * q2 - 1.0;
    q6=q2 * (4.0 * q2 * q2 - 3.0);
    r2=2.0 * ssig * csig;
    r3=ssig * (3.0 - 4.0 * ssig * ssig);
    final double s=sinalf * (ao * sig + a2 * ssig * q2 + a4 * r2 * q4 + a6 * r3 * q6);
    double xz=dlon + s;
    xy=abs(xz - ab);
    ab=dlon + s;
  }
 while (xy >= TOLERANCE_1);
  final double z=ESQP * w;
  final double bo=1.0 + z * (1.0 / 4.0 + z * (-3.0 / 64.0 + z * (5.0 / 256.0 - z * (175.0 / 16384.0))));
  final double b2=z * (-1.0 / 4.0 + z * (1.0 / 16.0 + z * (-15.0 / 512.0 + z * (35.0 / 2048.0))));
  final double b4=z * z * (-1.0 / 128.0 + z * (3.0 / 512.0 - z * (35.0 / 8192.0)));
  final double b6=z * z * z* (-1.0 / 1536.0 + z * (5.0 / 6144.0));
  distance=semiMinorAxis * (bo * sig + b2 * ssig * q2 + b4 * r2 * q4 + b6 * r3 * q6);
  double az1=(dlon < 0) ? PI * (3.0 / 2.0) : PI / 2;
  if ((abs(su1) >= TOLERANCE_0) || (abs(su2) >= TOLERANCE_0)) {
    final double tana1=slon * cu2 / (su2 * cu1 - clon * su1 * cu2);
    final double sina1=sinalf / cu1;
    az1=atan2(sina1,sina1 / tana1);
  }
  azimuth=castToAngleRange(az1);
  directionValid=true;
  return;
}
