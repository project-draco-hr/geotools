{
  final SimpleFeatureCollection features=adaptee.getGranules(q);
  if (features == null) {
    throw new NullPointerException("The provided SimpleFeatureCollection is null, it's impossible to create an index!");
  }
  if (LOGGER.isLoggable(Level.FINE)) {
    LOGGER.fine("Index Loaded");
  }
  final Utils.BBOXFilterExtractor bboxExtractor=new Utils.BBOXFilterExtractor();
  q.getFilter().accept(bboxExtractor,null);
  ReferencedEnvelope requestedBBox=bboxExtractor.getBBox();
  final Geometry intersectionGeometry=requestedBBox != null ? JTS.toGeometry(requestedBBox) : null;
  final DefaultProgressListener listener=new DefaultProgressListener();
  features.accepts(new AbstractFeatureVisitor(){
    public void visit(    Feature feature){
      if (feature instanceof SimpleFeature) {
        final SimpleFeature sf=(SimpleFeature)feature;
        GranuleDescriptor granule=null;
        String featureId=sf.getID();
        if (descriptorsCache.containsKey(featureId)) {
          granule=descriptorsCache.get(featureId);
        }
 else {
          MultiLevelROI footprint=getGranuleFootprint(sf);
          if (footprint == null || !footprint.isEmpty()) {
            granule=new GranuleDescriptor(sf,adaptee.suggestedRasterSPI,adaptee.pathType,adaptee.locationAttribute,adaptee.parentLocation,footprint,adaptee.heterogeneous,adaptee.hints);
            descriptorsCache.put(featureId,granule);
          }
        }
        if (granule != null) {
          final Geometry footprint=granule.getFootprint();
          if (intersectionGeometry == null || footprint == null || polygonOverlap(footprint,intersectionGeometry)) {
            visitor.visit(granule,null);
          }
 else {
            if (LOGGER.isLoggable(Level.FINE)) {
              LOGGER.fine("Skipping granule " + granule + "\n since its ROI does not intersect the requested area");
            }
          }
        }
        if (listener.isCanceled() || listener.hasExceptions()) {
          if (listener.hasExceptions()) {
            throw new RuntimeException(listener.getExceptions().peek());
          }
 else {
            throw new IllegalStateException("Feature visitor for query " + q + " has been canceled");
          }
        }
      }
    }
    private boolean polygonOverlap(    Geometry g1,    Geometry g2){
      Geometry intersection=g1.intersection(g2);
      return intersection != null && intersection.getDimension() == 2;
    }
  }
,listener);
}
