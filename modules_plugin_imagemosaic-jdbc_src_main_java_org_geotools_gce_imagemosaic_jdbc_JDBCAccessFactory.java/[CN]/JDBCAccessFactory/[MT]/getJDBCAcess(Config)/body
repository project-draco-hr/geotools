{
  JDBCAccess jdbcAccess=JDBCAccessMap.get(config.getXmlUrl());
  if (jdbcAccess != null) {
    return jdbcAccess;
  }
  SpatialExtension type=config.getSpatialExtension();
  if (type == null) {
    throw new Exception("Property <spatialExtension> missing");
  }
  if (type == SpatialExtension.DB2) {
    jdbcAccess=new JDBCAccessDB2(config);
  }
 else   if (type == SpatialExtension.POSTGIS) {
    jdbcAccess=new JDBCAccessPostGis(config);
  }
 else   if (type == SpatialExtension.MYSQL) {
    jdbcAccess=new JDBCAccessMySql(config);
  }
 else   if (type == SpatialExtension.UNIVERSAL) {
    jdbcAccess=new JDBCAccessUniversal(config);
  }
 else   if (type == SpatialExtension.ORACLE) {
    jdbcAccess=new JDBCAccessOracle(config);
  }
 else   if (type == SpatialExtension.GEORASTER) {
    jdbcAccess=new JDBCAccessOracleGeoRaster(config);
  }
 else   if (type == SpatialExtension.CUSTOM) {
    String jdbcAccessClassName=config.getJdbcAccessClassName();
    Class jdbcAccessClass=Class.forName(jdbcAccessClassName);
    try {
      Constructor cons=jdbcAccessClass.getConstructor(new Class[]{Config.class});
      jdbcAccess=(JDBCAccess)cons.newInstance(new Object[]{config});
    }
 catch (    Exception ex) {
      String msg="No public Constructor with an " + config.getClass().getName() + " argument for class "+ jdbcAccessClassName;
      throw new RuntimeException(msg,ex);
    }
  }
 else {
    throw new Exception("spatialExtension: " + type + " not supported");
  }
  jdbcAccess.initialize();
  JDBCAccessMap.put(config.getXmlUrl(),jdbcAccess);
  return jdbcAccess;
}
