{
  try {
    final SpatioTemporalImageReader reader=(SpatioTemporalImageReader)NetCDFDriver.spi.createReaderInstance();
    reader.setInput(this.input);
    int numCoverages=0;
    final Name mainCoverageName=Utilities.buildCoverageName(input);
    Name coverageName=mainCoverageName;
    final int numImages=reader.getNumImages(false);
    Map<Name,Map<String,NetCDFProductFieldType>> fieldsMap=new HashMap<Name,Map<String,NetCDFProductFieldType>>();
    for (int imageIndex=0; imageIndex < numImages; imageIndex++) {
      final SpatioTemporalMetadata metadata=reader.getSpatioTemporalMetadata(imageIndex);
      final SliceDescriptor sd=reader.getSliceDescriptor(imageIndex);
      if (sd == null)       throw new IllegalStateException("unable to get the required sliceDescriptor");
      BoundingBox boundingBox=sd.getHorizontalExtent();
      VerticalExtent ve=sd.getVerticalExtent();
      TemporalGeometricPrimitive time=sd.getTemporalExtent();
      int nDim=2;
      boolean hasVertical=false;
      if (ve != null) {
        nDim++;
        hasVertical=true;
      }
      if (time != null)       nDim++;
      Band sampleDim=metadata.getBand(0);
      Set<TemporalGeometricPrimitive> temporalExtent;
      Set<NumberRange<Double>> verticalExtent;
      Map<String,NetCDFProductFieldType> fields;
      HashMap<BoundingBox,Name> referenceMap=getNDMap(nDim,hasVertical);
      if (!referenceMap.containsKey(boundingBox)) {
        coverageName=new NameImpl(mainCoverageName.getLocalPart() + "_" + Integer.toString(numCoverages++));
        coverageNames.add(coverageName);
        referenceMap.put(boundingBox,coverageName);
        temporalExtent=new TreeSet<TemporalGeometricPrimitive>();
        verticalExtent=new TreeSet<NumberRange<Double>>(new Comparator<NumberRange<Double>>(){
          public int compare(          NumberRange<Double> one,          NumberRange<Double> two){
            final double min1=one.getMinimum(true);
            final double min2=two.getMinimum(true);
            if (one.contains(two) || two.contains(one))             return 0;
            if (min1 < min2)             return -1;
 else             return 1;
          }
        }
);
        fields=new HashMap<String,NetCDFProductFieldType>();
        temporalExtentMap.put(coverageName,temporalExtent);
        verticalExtentMap.put(coverageName,verticalExtent);
        fieldsMap.put(coverageName,fields);
      }
 else {
        coverageName=referenceMap.get(boundingBox);
      }
      if (!envelopesMap.containsKey(coverageName)) {
        initOriginalEnvelopeAndCRS(coverageName,sd);
        final GridGeometry2D gridGeometry2D=buildGridGeometry2D(coverageName,metadata);
        gridGeometry2DMap.put(coverageName,gridGeometry2D);
      }
 else {
        GeneralEnvelope envelope=envelopesMap.get(coverageName);
        envelope.add(sd.getGeneralEnvelope());
        envelopesMap.put(coverageName,envelope);
      }
      temporalExtent=temporalExtentMap.get(coverageName);
      verticalExtent=verticalExtentMap.get(coverageName);
      if (ve != null) {
        NumberRange<Double> verticalRange=NumberRange.create(ve.getMinimumValue().doubleValue(),ve.getMaximumValue().doubleValue());
        if (!verticalExtent.contains(verticalRange))         verticalExtent.add(verticalRange);
      }
      if (time != null) {
        if (!temporalExtent.contains(time))         temporalExtent.add(time);
      }
      fields=fieldsMap.get(coverageName);
      String elementName=sampleDim.getName();
      if (!fields.containsKey(elementName)) {
        Product product=NetCDFProductFieldType.getProduct(elementName);
        Unit<?> unit=Unit.ONE;
        if (product != null) {
          unit=product.getUoM();
        }
 else {
          String uOm=sampleDim.getUoM();
          if (uOm != null) {
            try {
              unit=Unit.valueOf(uOm);
            }
 catch (            IllegalArgumentException iae) {
              try {
                unit=Unit.ONE.alternate(uOm);
              }
 catch (              IllegalArgumentException iae2) {
                if (LOGGER.isLoggable(Level.FINE)) {
                  LOGGER.log(Level.FINE,"Unable to parse the provided unit " + uOm,iae2);
                }
              }
catch (              UnsupportedOperationException uoe) {
                if (LOGGER.isLoggable(Level.FINE)) {
                  LOGGER.log(Level.FINE,"Unable to parse the provided unit " + uOm,uoe);
                }
              }
            }
          }
        }
        final Name nameImpl=new NameImpl(coverageName.getLocalPart(),elementName);
        final InternationalString description=new SimpleInternationalString(elementName);
        final GridSampleDimension band=Utilities.buildBands(sampleDim,elementName,unit);
        final NetCDFProductFieldType fd=new NetCDFProductFieldType(nameImpl,description,band);
        fields.put(elementName,fd);
      }
      sliceDescriptorsMap.put(imageIndex,sd);
      spatioTemporalMetadataMap.put(imageIndex,metadata);
    }
    for (    Name covName : coverageNames) {
      Set<NumberRange<Double>> verticalExtent=verticalExtentMap.get(covName);
      if (verticalExtent.size() == 0) {
        verticalExtent=Collections.emptySet();
        verticalExtentMap.put(covName,verticalExtent);
      }
      Set<TemporalGeometricPrimitive> temporalExtent=temporalExtentMap.get(covName);
      if (temporalExtent.size() == 0) {
        temporalExtent=Collections.emptySet();
        temporalExtentMap.put(covName,temporalExtent);
      }
      Map<String,NetCDFProductFieldType> fields=fieldsMap.get(covName);
      if (fields != null && !fields.isEmpty()) {
        final Set<FieldType> fieldTypes=new LinkedHashSet<FieldType>(fields.size());
        final StringBuilder sb=new StringBuilder();
        for (        NetCDFProductFieldType fd : fields.values()) {
          fieldTypes.add(fd);
          final InternationalString description=fd.getDescription();
          sb.append(description != null ? description.toString() + "," : "");
        }
        String description=sb.toString();
        int pos=-1;
        if (description.length() > 0 && (pos=description.lastIndexOf(",")) != -1) {
          description=description.substring(0,pos);
        }
        DefaultRangeType range=new DefaultRangeType(covName,new SimpleInternationalString(description),fieldTypes);
        rangeMap.put(covName,range);
      }
    }
    numberOfCoverages=numCoverages;
    reader.dispose();
  }
 catch (  IOException e) {
    this.numberOfCoverages=1;
  }
catch (  FactoryException fe) {
    this.numberOfCoverages=1;
  }
catch (  TransformException fe) {
    this.numberOfCoverages=1;
  }
}
