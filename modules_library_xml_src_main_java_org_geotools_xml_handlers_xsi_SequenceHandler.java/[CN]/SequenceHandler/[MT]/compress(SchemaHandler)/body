{
synchronized (this) {
    if (cache != null)     return cache;
    cache=new DefaultSequence();
  }
  cache.id=id;
  cache.minOccurs=minOccurs;
  cache.maxOccurs=maxOccurs;
  logger.finest(id + " :: This Sequence has " + ((children == null) ? 0 : children.size())+ " children");
  if (children != null) {
    cache.children=new ElementGrouping[children.size()];
    for (int i=0; i < cache.children.length; i++)     cache.children[i]=((ElementGroupingHandler)children.get(i)).compress(parent);
  }
  children=null;
  id=null;
  return cache;
}
