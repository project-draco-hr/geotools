{
  clearAbortRequest();
  final Slice2DIndex slice2DIndex=getSlice2DIndex(imageIndex);
  final String variableName=slice2DIndex.getVariableName();
  final VariableAdapter wrapper=getCoverageDescriptor(new NameImpl(variableName));
  final int strideX, strideY;
  final int[] dstBands;
  if (param != null) {
    strideX=param.getSourceXSubsampling();
    strideY=param.getSourceYSubsampling();
    dstBands=param.getDestinationBands();
  }
 else {
    strideX=1;
    strideY=1;
    dstBands=null;
  }
  final int width=wrapper.getWidth();
  final int height=wrapper.getHeight();
  final Rectangle srcRegion=new Rectangle();
  final Rectangle destRegion=new Rectangle();
  computeRegions(param,width,height,null,srcRegion,destRegion);
  if (needsFlipping) {
    flipVertically(param,height,srcRegion);
  }
  int destWidth=destRegion.x + destRegion.width;
  int destHeight=destRegion.y + destRegion.height;
  final List<Range> ranges=new LinkedList<Range>();
  try {
    int first=slice2DIndex.getTIndex();
    int length=1;
    int stride=1;
    if (first != -1) {
      ranges.add(new Range(first,first + length - 1,stride));
    }
    first=slice2DIndex.getZIndex();
    if (first != -1) {
      ranges.add(new Range(first,first + length - 1,stride));
    }
    first=srcRegion.y;
    length=srcRegion.height;
    stride=strideY;
    ranges.add(new Range(first,first + length - 1,stride));
    first=srcRegion.x;
    length=srcRegion.width;
    stride=strideX;
    ranges.add(new Range(first,first + length - 1,stride));
  }
 catch (  InvalidRangeException e) {
    throw netcdfFailure(e);
  }
  final Section section=new Section(ranges);
  final SampleModel sampleModel=wrapper.getSampleModel().createCompatibleSampleModel(destWidth,destHeight);
  final ColorModel colorModel=ImageIOUtilities.createColorModel(sampleModel);
  final WritableRaster raster=Raster.createWritableRaster(sampleModel,new Point(0,0));
  Hashtable<String,Object> properties=getNoDataProperties(wrapper);
  final BufferedImage image=new BufferedImage(colorModel,raster,colorModel.isAlphaPremultiplied(),properties);
  CoordinateAxis axis=wrapper.variableDS.getCoordinateSystems().get(0).getLatAxis();
  boolean flipYAxis=false;
  try {
    Array yAxisStart=axis.read(new Section().appendRange(2));
    float y1=yAxisStart.getFloat(0);
    float y2=yAxisStart.getFloat(1);
    if (y2 > y1) {
      flipYAxis=true;
    }
  }
 catch (  InvalidRangeException e) {
    throw new RuntimeException(e);
  }
  processImageStarted(imageIndex);
  final int numDstBands=1;
  final float toPercent=100f / numDstBands;
  final int type=raster.getSampleModel().getDataType();
  final int xmin=destRegion.x;
  final int ymin=destRegion.y;
  final int xmax=destRegion.width + xmin;
  final int ymax=destRegion.height + ymin;
  for (int zi=0; zi < numDstBands; zi++) {
    final int dstBand=(dstBands == null) ? zi : dstBands[zi];
    final Array array;
    try {
      array=wrapper.variableDS.read(section);
    }
 catch (    InvalidRangeException e) {
      throw netcdfFailure(e);
    }
    if (flipYAxis) {
      final IndexIterator it=array.getIndexIterator();
      for (int y=ymax; --y >= ymin; ) {
        for (int x=xmin; x < xmax; x++) {
switch (type) {
case DataBuffer.TYPE_DOUBLE:
{
              raster.setSample(x,y,dstBand,it.getDoubleNext());
              break;
            }
case DataBuffer.TYPE_FLOAT:
{
            raster.setSample(x,y,dstBand,it.getFloatNext());
            break;
          }
case DataBuffer.TYPE_BYTE:
{
          byte b=it.getByteNext();
          raster.setSample(x,y,dstBand,b);
          break;
        }
default :
{
        raster.setSample(x,y,dstBand,it.getIntNext());
        break;
      }
  }
}
}
}
 else {
switch (type) {
case DataBuffer.TYPE_DOUBLE:
{
  DoubleBuffer doubleBuffer=array.getDataAsByteBuffer().asDoubleBuffer();
  double[] samples=new double[destRegion.width * destRegion.height];
  doubleBuffer.get(samples);
  raster.setSamples(xmin,ymin,destRegion.width,destRegion.height,dstBand,samples);
  break;
}
case DataBuffer.TYPE_FLOAT:
float[] samples=new float[destRegion.width * destRegion.height];
FloatBuffer floatBuffer=array.getDataAsByteBuffer().asFloatBuffer();
floatBuffer.get(samples);
raster.setSamples(xmin,ymin,destRegion.width,destRegion.height,dstBand,samples);
break;
case DataBuffer.TYPE_BYTE:
raster.setDataElements(xmin,ymin,destRegion.width,destRegion.height,array.getDataAsByteBuffer().array());
break;
case DataBuffer.TYPE_INT:
IntBuffer intBuffer=array.getDataAsByteBuffer().asIntBuffer();
int[] intSamples=new int[destRegion.width * destRegion.height];
intBuffer.get(intSamples);
raster.setSamples(xmin,ymin,destRegion.width,destRegion.height,dstBand,intSamples);
break;
default :
{
final IndexIterator it=array.getIndexIterator();
for (int y=ymin; y < ymax; y++) {
for (int x=xmin; x < xmax; x++) {
raster.setSample(x,y,dstBand,it.getIntNext());
}
}
break;
}
}
}
if (abortRequested()) {
processReadAborted();
return image;
}
processImageProgress(zi * toPercent);
}
processImageComplete();
return image;
}
