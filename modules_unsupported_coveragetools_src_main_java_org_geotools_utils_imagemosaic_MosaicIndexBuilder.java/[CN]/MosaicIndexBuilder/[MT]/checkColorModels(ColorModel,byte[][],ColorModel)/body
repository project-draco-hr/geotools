{
  if (defaultCM instanceof ComponentColorModel && actualCM instanceof ComponentColorModel) {
    final ComponentColorModel defCCM=(ComponentColorModel)defaultCM, actualCCM=(ComponentColorModel)actualCM;
    return !(defCCM.getNumColorComponents() == actualCCM.getNumColorComponents() && defCCM.hasAlpha() == actualCCM.hasAlpha() && defCCM.getColorSpace().equals(actualCCM.getColorSpace()) && defCCM.getTransparency() == actualCCM.getTransparency() && defCCM.getTransferType() == actualCCM.getTransferType());
  }
  if (defaultCM instanceof IndexColorModel && actualCM instanceof IndexColorModel) {
    final IndexColorModel defICM=(IndexColorModel)defaultCM, actualICM=(IndexColorModel)actualCM;
    if (defICM.getNumColorComponents() != actualICM.getNumColorComponents() || defICM.hasAlpha() != actualICM.hasAlpha() || !defICM.getColorSpace().equals(actualICM.getColorSpace()) || defICM.getTransferType() != actualICM.getTransferType())     return true;
    if (defICM.getMapSize() != actualICM.getMapSize() || defICM.getTransparency() != actualICM.getTransparency() || defICM.getTransferType() != actualICM.getTransferType() || defICM.getTransparentPixel() != actualICM.getTransparentPixel()) {
      mustConvertToRGB=true;
      return false;
    }
    int numBands=actualICM.getNumColorComponents();
    byte[][] actualPalette=new byte[3][actualICM.getMapSize()];
    actualICM.getReds(actualPalette[0]);
    actualICM.getGreens(actualPalette[0]);
    actualICM.getBlues(actualPalette[0]);
    if (numBands == 4)     actualICM.getAlphas(defaultPalette[0]);
    for (int i=0; i < defICM.getMapSize(); i++)     for (int j=0; j < numBands; j++)     if (actualPalette[j][i] != defaultPalette[j][i]) {
      mustConvertToRGB=true;
      break;
    }
    return false;
  }
  return true;
}
