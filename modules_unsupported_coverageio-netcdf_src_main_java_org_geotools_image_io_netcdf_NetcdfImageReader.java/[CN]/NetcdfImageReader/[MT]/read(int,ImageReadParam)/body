{
  clearAbortRequest();
  prepareVariable(imageIndex);
  final int strideX, strideY;
  final int[] srcBands, dstBands;
  if (param != null) {
    strideX=param.getSourceXSubsampling();
    strideY=param.getSourceYSubsampling();
    srcBands=param.getSourceBands();
    dstBands=param.getDestinationBands();
  }
 else {
    strideX=1;
    strideY=1;
    srcBands=null;
    dstBands=null;
  }
  final int rank=variable.getRank();
  int bandDimension=rank - Z_DIMENSION;
  if (false && param instanceof NetcdfReadParam) {
    final NetcdfReadParam p=(NetcdfReadParam)param;
    if (p.isBandDimensionSet() && variable instanceof VariableEnhanced) {
      ensureMetadataLoaded();
      bandDimension=p.getBandDimension((VariableEnhanced)variable);
      final int relative=rank - bandDimension;
      if (relative < 0 || relative == X_DIMENSION || relative == Y_DIMENSION) {
        throw new IllegalArgumentException(Errors.format(ErrorKeys.BAD_PARAMETER_$2,"bandDimension",bandDimension));
      }
    }
  }
  final int width=variable.getDimension(rank - X_DIMENSION).getLength();
  final int height=variable.getDimension(rank - Y_DIMENSION).getLength();
  final SampleConverter[] converters=new SampleConverter[1];
  final BufferedImage image=getDestination(imageIndex,param,width,height,converters);
  final WritableRaster raster=image.getRaster();
  final SampleConverter converter=first(converters);
  final boolean hasBands=(bandDimension >= 0 && bandDimension < rank);
  final int numSrcBands=hasBands ? variable.getDimension(bandDimension).getLength() : 1;
  final int numDstBands=raster.getNumBands();
  if (param != null) {
    checkReadParamBandSettings(param,numSrcBands,numDstBands);
  }
  final Rectangle srcRegion=new Rectangle();
  final Rectangle destRegion=new Rectangle();
  computeRegions(param,width,height,image,srcRegion,destRegion);
  flipVertically(param,height,srcRegion);
  final Range[] ranges=new Range[rank];
  for (int i=0; i < ranges.length; i++) {
    final int first, length, stride;
switch (rank - i) {
case X_DIMENSION:
{
        first=srcRegion.x;
        length=srcRegion.width;
        stride=strideX;
        break;
      }
case Y_DIMENSION:
{
      first=srcRegion.y;
      length=srcRegion.height;
      stride=strideY;
      break;
    }
default :
{
    if (i == bandDimension) {
      first=NetcdfReadParam.DEFAULT_INDICE;
    }
 else {
      first=getSliceIndice(param,i);
    }
    length=1;
    stride=1;
    break;
  }
}
try {
ranges[i]=new Range(first,first + length - 1,stride);
}
 catch (InvalidRangeException e) {
throw netcdfFailure(e);
}
}
final List<Range> sections=Range.toList(ranges);
processImageStarted(imageIndex);
final float toPercent=100f / numDstBands;
final int type=raster.getSampleModel().getDataType();
final int xmin=destRegion.x;
final int ymin=destRegion.y;
final int xmax=destRegion.width + xmin;
final int ymax=destRegion.height + ymin;
for (int zi=0; zi < numDstBands; zi++) {
final int srcBand=(srcBands == null) ? zi : srcBands[zi];
final int dstBand=(dstBands == null) ? zi : dstBands[zi];
final Array array;
try {
if (hasBands) {
  ranges[bandDimension]=new Range(srcBand,srcBand,1);
}
array=variable.read(sections);
}
 catch (InvalidRangeException e) {
throw netcdfFailure(e);
}
final IndexIterator it=array.getIndexIterator();
for (int y=ymax; --y >= ymin; ) {
for (int x=xmin; x < xmax; x++) {
switch (type) {
case DataBuffer.TYPE_DOUBLE:
{
      raster.setSample(x,y,dstBand,converter.convert(it.getDoubleNext()));
      break;
    }
case DataBuffer.TYPE_FLOAT:
{
    raster.setSample(x,y,dstBand,converter.convert(it.getFloatNext()));
    break;
  }
default :
{
  raster.setSample(x,y,dstBand,converter.convert(it.getIntNext()));
  break;
}
}
}
}
if (abortRequested()) {
processReadAborted();
return image;
}
processImageProgress(zi * toPercent);
}
if (lastError != null) {
throw new IIOException(lastError);
}
processImageComplete();
return image;
}
