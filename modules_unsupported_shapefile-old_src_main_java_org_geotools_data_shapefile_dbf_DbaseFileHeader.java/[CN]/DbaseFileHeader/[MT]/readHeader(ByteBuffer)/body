{
  in.order(ByteOrder.LITTLE_ENDIAN);
  byte magic=in.get();
  if (magic != MAGIC) {
    throw new IOException("Unsupported DBF file Type " + Integer.toHexString(magic));
  }
  int tempUpdateYear=in.get();
  int tempUpdateMonth=in.get();
  int tempUpdateDay=in.get();
  if (tempUpdateYear > 90) {
    tempUpdateYear=tempUpdateYear + 1900;
  }
 else {
    tempUpdateYear=tempUpdateYear + 2000;
  }
  Calendar c=Calendar.getInstance();
  c.set(Calendar.YEAR,tempUpdateYear);
  c.set(Calendar.MONTH,tempUpdateMonth - 1);
  c.set(Calendar.DATE,tempUpdateDay);
  date=c.getTime();
  recordCnt=in.getInt();
  headerLength=(in.get() & 0xff) | ((in.get() & 0xff) << 8);
  if (headerLength > in.capacity()) {
    throw new IllegalArgumentException("The contract says the buffer should be long enough to fit all the header!");
  }
  recordLength=(in.get() & 0xff) | ((in.get() & 0xff) << 8);
  in.position(in.position() + 20);
  fieldCnt=(headerLength - FILE_DESCRIPTOR_SIZE - 1) / FILE_DESCRIPTOR_SIZE;
  List lfields=new ArrayList();
  for (int i=0; i < fieldCnt; i++) {
    DbaseField field=new DbaseField();
    byte[] buffer=new byte[11];
    in.get(buffer);
    String name=new String(buffer);
    int nullPoint=name.indexOf(0);
    if (nullPoint != -1) {
      name=name.substring(0,nullPoint);
    }
    field.fieldName=name.trim();
    field.fieldType=(char)in.get();
    field.fieldDataAddress=in.getInt();
    int length=(int)in.get();
    if (length < 0) {
      length=length + 256;
    }
    field.fieldLength=length;
    if (length > largestFieldSize) {
      largestFieldSize=length;
    }
    field.decimalCount=(int)in.get();
    in.position(in.position() + 14);
    if (field.fieldLength > 0) {
      lfields.add(field);
    }
  }
  in.position(in.position() + 1);
  fields=new DbaseField[lfields.size()];
  fields=(DbaseField[])lfields.toArray(fields);
}
