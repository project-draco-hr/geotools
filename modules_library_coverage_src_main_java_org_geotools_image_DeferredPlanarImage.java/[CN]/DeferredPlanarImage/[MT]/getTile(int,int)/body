{
  if (requests == null) {
    requests=new TileRequest[getNumXTiles() * getNumYTiles()];
  }
  final int tileIndice=getTileIndice(tileX,tileY);
  TileRequest request=requests[tileIndice];
  if (request == null) {
    request=image.queueTiles(new Point[]{new Point(tileX,tileY)});
    requests[tileIndice]=request;
  }
switch (request.getTileStatus(tileX,tileY)) {
default :
{
      LOGGER.warning("Unknow tile status");
    }
case TileRequest.TILE_STATUS_CANCELLED:
case TileRequest.TILE_STATUS_FAILED:
case TileRequest.TILE_STATUS_COMPUTED:
  return image.getTile(tileX,tileY);
case TileRequest.TILE_STATUS_PENDING:
case TileRequest.TILE_STATUS_PROCESSING:
break;
}
if (pendings != null) {
if (pendings[tileIndice] != null) {
return pendings[tileIndice];
}
}
if (delay != 0) {
if (waitings == null) {
waitings=new boolean[requests.length];
}
waitings[tileIndice]=true;
try {
wait(delay);
}
 catch (final InterruptedException exception) {
}
waitings[tileIndice]=false;
switch (request.getTileStatus(tileX,tileY)) {
default :
return image.getTile(tileX,tileY);
case TileRequest.TILE_STATUS_PENDING:
case TileRequest.TILE_STATUS_PROCESSING:
break;
}
}
if (LOGGER.isLoggable(Level.FINER)) {
final LogRecord record=Loggings.format(Level.FINER,LoggingKeys.DEFERRED_TILE_PAINTING_$2,tileX,tileY);
record.setSourceClassName(DeferredPlanarImage.class.getName());
record.setSourceMethodName("getTile");
record.setLoggerName(LOGGER.getName());
LOGGER.log(record);
}
if (pendings == null) {
pendings=new Raster[requests.length];
}
final Point origin=new Point(tileXToX(tileX),tileYToY(tileY));
final DataBuffer buffer=getDefaultDataBuffer(sampleModel,colorModel);
final Raster raster=Raster.createRaster(sampleModel,buffer,origin);
pendings[tileIndice]=raster;
fireTileUpdate(tileX,tileY,true);
return raster;
}
