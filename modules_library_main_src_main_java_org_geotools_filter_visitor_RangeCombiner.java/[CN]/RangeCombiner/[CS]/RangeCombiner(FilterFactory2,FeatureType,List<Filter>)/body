{
  this.ff=ff;
  this.filters=filters;
  this.featureType=featureType;
  this.expressionTypeVisitor=new ExpressionTypeVisitor(featureType);
  for (  Filter f : filters) {
    if (f instanceof PropertyIsBetween) {
      PropertyIsBetween pb=(PropertyIsBetween)f;
      Class binding=getTypeIfComparable(pb.getExpression());
      if (binding == null) {
        otherFilters.add(pb);
      }
 else {
        Object min=evaluate(pb.getLowerBoundary(),binding);
        Object max=evaluate(pb.getUpperBoundary(),binding);
        if (min == null || max == null) {
          otherFilters.add(f);
        }
 else {
          Expression expression=pb.getExpression();
          Range<?> range=new Range(binding,(Comparable)min,(Comparable)max);
          addRange(rangeMap,expression,new MultiRange(range));
        }
      }
    }
 else     if (f instanceof PropertyIsNotEqualTo) {
      PropertyIsNotEqualTo ne=(PropertyIsNotEqualTo)f;
      Comparable exclusion=null;
      Expression expression=null;
      Class<Comparable<?>> binding=getTypeIfComparable(ne.getExpression1());
      if (binding != null) {
        expression=ne.getExpression1();
        if (binding != null) {
          exclusion=evaluate(ne.getExpression2(),binding);
        }
      }
 else {
        expression=ne.getExpression2();
        binding=getTypeIfComparable(ne.getExpression2());
        if (binding != null) {
          exclusion=evaluate(ne.getExpression1(),binding);
        }
      }
      if (exclusion != null) {
        addRange(rangeMap,expression,new MultiRange(binding,exclusion));
      }
 else {
        otherFilters.add(f);
      }
    }
 else     if (f instanceof BinaryComparisonOperator) {
      BinaryComparisonOperator op=(BinaryComparisonOperator)f;
      ExpressionRange er=getRange(op);
      if (er.range != null && (!(op instanceof PropertyIsEqualTo) || (op.isMatchingCase()))) {
        addRange(rangeMap,er.expression,new MultiRange(er.range));
      }
 else {
        otherFilters.add(f);
      }
    }
 else     if (f instanceof org.opengis.filter.And || f instanceof org.opengis.filter.Or) {
      BinaryLogicOperator logic=(BinaryLogicOperator)f;
      List<Filter> children=logic.getChildren();
      RangeCombiner subCombiner;
      if (logic instanceof org.opengis.filter.And) {
        subCombiner=new RangeCombiner.And(ff,featureType,children);
      }
 else {
        subCombiner=new RangeCombiner.Or(ff,featureType,children);
      }
      if (!subCombiner.otherFilters.isEmpty() || (subCombiner.rangeMap.size() > 1 && !subCombiner.getClass().equals(this.getClass()))) {
        otherFilters.add(f);
      }
 else {
        Map<Expression,MultiRange> combined=subCombiner.rangeMap;
        for (        Map.Entry<Expression,MultiRange> entry : combined.entrySet()) {
          Expression ex=entry.getKey();
          MultiRange ranges=entry.getValue();
          addRange(rangeMap,ex,ranges);
        }
      }
    }
 else {
      otherFilters.add(f);
    }
  }
}
