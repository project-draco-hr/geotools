{
  if (Geometry.class.isAssignableFrom(source) && CurvedGeometry.class.isAssignableFrom(target)) {
    return new Converter(){
      @Override public <T>T convert(      Object source,      Class<T> target) throws Exception {
        Geometry result=null;
        Geometry sourceGeometry=(Geometry)source;
        if (MultiCurvedGeometry.class.isAssignableFrom(target)) {
          MultiLineString multiLineString=Converters.convert(source,MultiLineString.class);
          if (multiLineString == null) {
            return null;
          }
 else {
            List<LineString> components=new ArrayList<>();
            double tolerance=Double.MAX_VALUE;
            for (int i=0; i < multiLineString.getNumGeometries(); i++) {
              LineString geom=(LineString)multiLineString.getGeometryN(0);
              if (geom instanceof CurvedGeometry) {
                tolerance=Math.min(tolerance,((CurvedGeometry)geom).getTolerance());
              }
              components.add(geom);
            }
            GeometryFactory factory=((Geometry)source).getFactory();
            result=new MultiCurve(components,factory,tolerance);
          }
        }
 else         if (source instanceof CircularRing && CircularString.class.isAssignableFrom(target)) {
          CircularRing cr=(CircularRing)source;
          result=new CircularString(cr.getControlPoints(),cr.getFactory(),cr.getTolerance());
        }
 else         if (source instanceof CompoundRing && CompoundCurve.class.isAssignableFrom(target)) {
          CompoundRing cr=(CompoundRing)source;
          result=new CompoundCurve(cr.getComponents(),cr.getFactory(),cr.getTolerance());
        }
 else {
          LineString converted=Converters.convert(source,LineString.class);
          if (converted.isEmpty()) {
            List<LineString> components=new ArrayList<>();
            result=new CompoundRing(components,converted.getFactory(),Double.MAX_VALUE);
          }
 else           if (converted instanceof LinearRing) {
            result=new CompoundRing(Arrays.asList(converted),((LineString)source).getFactory(),Double.MAX_VALUE);
          }
 else {
            result=new CompoundCurve(Arrays.asList(converted),converted.getFactory(),Double.MAX_VALUE);
          }
        }
        if (result != null) {
          copyUserProperties(sourceGeometry,result);
        }
        return (T)result;
      }
    }
;
  }
 else   if (Geometry.class.isAssignableFrom(source) && Geometry.class.isAssignableFrom(target)) {
    return new Converter(){
      /** 
 * Converts all the geometries of the given GeometryCollection to a specified
 * simple type.
 * @param<T>
 * @param gc
 * @param target
 * @return
 * @throws Exception
 */
      public <T>List<T> convertAll(      GeometryCollection gc,      Class<T> target) throws Exception {
        List<T> result=new ArrayList<T>();
        for (int count=0; count < gc.getNumGeometries(); count++) {
          T geo=(T)convert(gc.getGeometryN(count),target);
          if (geo != null)           result.add(geo);
        }
        return result;
      }
      public Object convert(      Object source,      Class target) throws Exception {
        if (target.isAssignableFrom(source.getClass()))         return source;
        if (source instanceof Geometry) {
          Geometry sourceGeometry=(Geometry)source;
          Geometry destGeometry=null;
          if (MultiPoint.class.isAssignableFrom(target)) {
            Point[] points;
            if (sourceGeometry.isEmpty())             points=new Point[0];
 else             if (source instanceof Point)             points=new Point[]{(Point)source};
 else             if (source instanceof GeometryCollection)             points=this.convertAll((GeometryCollection)source,Point.class).toArray(new Point[]{});
 else             points=new Point[]{(Point)this.convert(source,Point.class)};
            destGeometry=gFac.createMultiPoint(points);
          }
 else           if (MultiLineString.class.isAssignableFrom(target)) {
            LineString[] lineStrings;
            if (sourceGeometry.isEmpty())             lineStrings=new LineString[0];
 else             if (source instanceof LineString)             lineStrings=new LineString[]{(LineString)source};
 else             if (source instanceof GeometryCollection)             lineStrings=this.convertAll((GeometryCollection)source,LineString.class).toArray(new LineString[]{});
 else             lineStrings=new LineString[]{(LineString)this.convert(source,LineString.class)};
            destGeometry=gFac.createMultiLineString(lineStrings);
          }
 else           if (MultiPolygon.class.isAssignableFrom(target)) {
            Polygon[] polygons;
            if (sourceGeometry.isEmpty())             polygons=new Polygon[0];
 else             if (source instanceof Polygon)             polygons=new Polygon[]{(Polygon)source};
 else             if (source instanceof GeometryCollection)             polygons=this.convertAll((GeometryCollection)source,Polygon.class).toArray(new Polygon[]{});
 else             polygons=new Polygon[]{(Polygon)this.convert(source,Polygon.class)};
            destGeometry=gFac.createMultiPolygon(polygons);
          }
 else           if (GeometryCollection.class.isAssignableFrom(target)) {
            if (sourceGeometry.isEmpty())             destGeometry=gFac.createGeometryCollection(new Geometry[0]);
 else             destGeometry=gFac.createGeometryCollection(new Geometry[]{(Geometry)source});
          }
 else           if (Point.class.isAssignableFrom(target)) {
            if (sourceGeometry.isEmpty())             destGeometry=gFac.createPoint((Coordinate)null);
 else             if (source instanceof MultiPoint && sourceGeometry.getNumGeometries() == 1)             destGeometry=(Geometry)((MultiPoint)source).getGeometryN(0).clone();
 else {
              if (LOGGER.isLoggable(Level.FINE))               LOGGER.fine("Converting Geometry " + source.toString() + " to Point. This could be unsafe");
              destGeometry=((Geometry)source).getCentroid();
            }
          }
 else           if (LineString.class.isAssignableFrom(target)) {
            if (sourceGeometry.isEmpty())             destGeometry=gFac.createLineString(new Coordinate[0]);
 else             if (source instanceof MultiLineString && sourceGeometry.getNumGeometries() == 1)             destGeometry=(Geometry)((MultiLineString)source).getGeometryN(0).clone();
 else {
              if (LOGGER.isLoggable(Level.FINE))               LOGGER.fine("Converting Geometry " + source.toString() + " to LineString. This could be unsafe");
              destGeometry=gFac.createLineString(getLineStringCoordinates(((Geometry)source).getCoordinates()));
            }
          }
 else           if (Polygon.class.isAssignableFrom(target)) {
            if (sourceGeometry.isEmpty())             destGeometry=gFac.createLineString(new Coordinate[0]);
 else             if (source instanceof MultiPolygon && sourceGeometry.getNumGeometries() == 1)             destGeometry=(Geometry)((MultiPolygon)source).getGeometryN(0).clone();
 else {
              if (LOGGER.isLoggable(Level.FINE))               LOGGER.fine("Converting Geometry " + source.toString() + " to Polygon. This could be unsafe");
              Coordinate[] coords=getPolygonCoordinates(((Geometry)source).getCoordinates());
              destGeometry=gFac.createPolygon(gFac.createLinearRing(coords),new LinearRing[]{});
            }
          }
          copyUserProperties(sourceGeometry,destGeometry);
          return destGeometry;
        }
        return null;
      }
      @SuppressWarnings("unchecked") private <T>T[] arrayCopy(      T[] original,      int length){
        Class<?> arrayType=original.getClass().getComponentType();
        T[] copy=(T[])java.lang.reflect.Array.newInstance(arrayType,length);
        System.arraycopy(original,0,copy,0,original.length < length ? original.length : length);
        return copy;
      }
      /** 
 * Add dummy coordinates to the given array to reach
 * numpoints points.
 * If the array is already made of numpoints or
 * more coordinates, it will be returned untouched.
 * @param input
 * @param numpoints
 * @return
 */
      private Coordinate[] growCoordinatesNum(      Coordinate[] input,      int numpoints){
        if (input.length < numpoints) {
          Coordinate[] newCoordinates=arrayCopy(input,numpoints);
          Arrays.fill(newCoordinates,input.length,numpoints,input[0]);
          input=newCoordinates;
        }
        return input;
      }
      /** 
 * Gets a set of coordinates valid to create a linestring:
 * - at least 2 coordinates
 * @param coordinates
 * @return
 */
      private Coordinate[] getLineStringCoordinates(      Coordinate[] coordinates){
        coordinates=growCoordinatesNum(coordinates,2);
        return coordinates;
      }
      /** 
 * Gets a set of coordinates valid to create a polygon:
 * - at least 4 coordinates
 * - closed path
 * @param coordinates
 * @return
 */
      private Coordinate[] getPolygonCoordinates(      Coordinate[] coordinates){
        coordinates=growCoordinatesNum(coordinates,4);
        if (!coordinates[coordinates.length - 1].equals(coordinates[0])) {
          Coordinate[] newCoordinates=arrayCopy(coordinates,coordinates.length + 1);
          newCoordinates[newCoordinates.length - 1]=newCoordinates[0];
          coordinates=newCoordinates;
        }
        return coordinates;
      }
    }
;
  }
  return null;
}
