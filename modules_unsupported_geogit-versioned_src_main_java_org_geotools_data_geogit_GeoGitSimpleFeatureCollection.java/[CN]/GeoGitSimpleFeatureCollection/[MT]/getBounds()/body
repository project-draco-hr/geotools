{
  if (this.cachedBounds != null) {
    return this.cachedBounds;
  }
  final CoordinateReferenceSystem crs=type.getCoordinateReferenceSystem();
  ReferencedEnvelope bounds=new ReferencedEnvelope(crs);
  if (BigInteger.ZERO.equals(typeTree.size())) {
    return bounds;
  }
  final FeatureRefIterator refs=new FeatureRefIterator(typeTree,filter);
  BoundingBox featureBounds;
  try {
    if (refs.isFullySupported()) {
      while (refs.hasNext()) {
        Ref ref=refs.next();
        if (ref instanceof SpatialRef) {
          SpatialRef sp=(SpatialRef)ref;
          featureBounds=sp.getBounds();
          reprojector.expandToInclude(bounds,featureBounds);
        }
      }
    }
 else {
      Iterator<SimpleFeature> features=new GeoGitFeatureIterator(refs,type,filter,odb);
      while (features.hasNext()) {
        featureBounds=features.next().getBounds();
        reprojector.expandToInclude(bounds,featureBounds);
      }
    }
  }
 catch (  TransformException e) {
    throw new RuntimeException(e);
  }
  this.cachedBounds=bounds;
  return bounds;
}
