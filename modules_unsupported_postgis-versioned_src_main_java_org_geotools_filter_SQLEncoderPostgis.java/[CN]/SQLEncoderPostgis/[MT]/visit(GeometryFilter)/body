{
  LOGGER.finer("exporting GeometryFilter");
  short filterType=filter.getFilterType();
  DefaultExpression left=(DefaultExpression)filter.getLeftGeometry();
  DefaultExpression right=(DefaultExpression)filter.getRightGeometry();
  if (!supportsGEOS) {
    if (filterType != AbstractFilter.GEOMETRY_BBOX) {
      throw new RuntimeException("without GEOS support, only the BBOX function is supported; failed to encode " + filterType);
    }
    encodeGeomFilter(filter,"distance"," < 0.00001",true);
    return;
  }
  int literalGeometryCount=0;
  if ((left != null) && (left.getType() == DefaultExpression.LITERAL_GEOMETRY)) {
    literalGeometryCount++;
  }
  if ((right != null) && (right.getType() == DefaultExpression.LITERAL_GEOMETRY)) {
    literalGeometryCount++;
  }
  boolean constrainBBOX=(literalGeometryCount == 1);
  boolean onlyBbox=filterType == AbstractFilter.GEOMETRY_BBOX && looseBbox;
  try {
    constrainBBOX=constrainBBOX && (filterType != AbstractFilter.GEOMETRY_DISJOINT);
    if (constrainBBOX) {
      encodeExpression(left);
      out.write(" && ");
      encodeExpression(right);
      if (!onlyBbox) {
        out.write(" AND ");
      }
    }
    String closingParenthesis=")";
    if (!onlyBbox) {
      if (filterType == AbstractFilter.GEOMETRY_EQUALS) {
        out.write("equals");
      }
 else       if (filterType == AbstractFilter.GEOMETRY_DISJOINT) {
        out.write("NOT (intersects");
        closingParenthesis+=")";
      }
 else       if (filterType == AbstractFilter.GEOMETRY_INTERSECTS) {
        out.write("intersects");
      }
 else       if (filterType == AbstractFilter.GEOMETRY_CROSSES) {
        out.write("crosses");
      }
 else       if (filterType == AbstractFilter.GEOMETRY_WITHIN) {
        out.write("within");
      }
 else       if (filterType == AbstractFilter.GEOMETRY_CONTAINS) {
        out.write("contains");
      }
 else       if (filterType == AbstractFilter.GEOMETRY_OVERLAPS) {
        out.write("overlaps");
      }
 else       if (filterType == AbstractFilter.GEOMETRY_BBOX) {
        out.write("intersects");
      }
 else       if (filterType == AbstractFilter.GEOMETRY_TOUCHES) {
        out.write("touches");
      }
 else {
        throw new RuntimeException("does not support filter type " + filterType);
      }
      out.write("(");
      encodeExpression(left);
      out.write(", ");
      encodeExpression(right);
      out.write(closingParenthesis);
    }
  }
 catch (  java.io.IOException ioe) {
    LOGGER.warning("Unable to export filter" + ioe);
    throw new RuntimeException("io error while writing",ioe);
  }
}
