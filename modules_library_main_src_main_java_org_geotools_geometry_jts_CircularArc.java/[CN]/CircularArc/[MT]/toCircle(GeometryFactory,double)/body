{
  initializeCenterRadius();
  double sx=controlPoints[0];
  double sy=controlPoints[1];
  double mx=controlPoints[2];
  double my=controlPoints[3];
  double ex=controlPoints[4];
  double ey=controlPoints[5];
  double sa=atan2(sy - centerY,sx - centerX);
  double ma=atan2(my - centerY,mx - centerX);
  double ea=atan2(ey - centerY,ex - centerX);
  boolean clockwise=(sa > ma && ma > ea) || (sa > ma && sa < ea) || (ma > ea && sa < ea);
  if (clockwise) {
    double tx=sx;
    sx=ex;
    ex=tx;
    double ty=sy;
    sy=ey;
    ey=ty;
    double ta=sa;
    sa=ea;
    ea=ta;
  }
  if (ma < sa) {
    ma+=PI_PI;
    ea+=PI_PI;
  }
 else   if (ea < sa) {
    ea+=PI_PI;
  }
  double ea2=sa + PI_PI;
  double ma2=(ea + ea2) / 2;
  double mx2=centerX + radius * cos(ma2);
  double my2=centerY + radius * sin(ma2);
  double[] rcp=new double[10];
  rcp[0]=sx;
  rcp[1]=sy;
  rcp[2]=mx;
  rcp[3]=my;
  rcp[4]=ex;
  rcp[5]=ey;
  rcp[6]=mx2;
  rcp[7]=my2;
  rcp[8]=sx;
  rcp[9]=sy;
  return new CircularRing(rcp,geometryFactory,tolerance);
}
