{
  JoiningQuery query=new JoiningQuery();
  query.setCoordinateSystemReproject(reprojection);
  FeatureTypeMapping fMapping=AppSchemaDataAccessRegistry.getMappingByName(featureTypeName);
  AttributeMapping mapping=fMapping.getAttributeMapping(this.nestedTargetXPath);
  if (mapping == null) {
    throw new IllegalArgumentException("Mapping is missing for: '" + this.nestedTargetXPath + "'!");
  }
  Expression nestedSourceExpression=mapping.getSourceExpression();
  List<JoiningQuery.QueryJoin> joins=new ArrayList<JoiningQuery.QueryJoin>();
  if (instance.baseTableQuery instanceof JoiningQuery) {
    if (((JoiningQuery)instance.baseTableQuery).getQueryJoins() != null) {
      joins.addAll(((JoiningQuery)instance.baseTableQuery).getQueryJoins());
    }
  }
  JoiningQuery.QueryJoin join=new JoiningQuery.QueryJoin();
  join.setForeignKeyName(sourceExpression);
  join.setJoiningKeyName(nestedSourceExpression);
  join.setJoiningTypeName(instance.baseTableQuery.getTypeName());
  join.setSortBy(instance.baseTableQuery.getSortBy());
  FilterAttributeExtractor extractor=new FilterAttributeExtractor();
  instance.mapping.getFeatureIdExpression().accept(extractor,null);
  for (  String pn : extractor.getAttributeNameSet()) {
    join.addId(pn);
  }
  joins.add(0,join);
  query.setQueryJoins(joins);
  if (selectedProperties != null) {
    selectedProperties=new ArrayList<PropertyName>(selectedProperties);
    selectedProperties.add(filterFac.property(this.nestedTargetXPath.toString()));
  }
  final Hints hints=new Hints();
  hints.put(Query.INCLUDE_MANDATORY_PROPS,includeMandatory);
  if (resolveDepth > 0) {
    hints.put(Hints.RESOLVE,ResolveValueType.ALL);
    hints.put(Hints.ASSOCIATION_TRAVERSAL_DEPTH,resolveDepth);
    hints.put(Hints.RESOLVE_TIMEOUT,resolveTimeOut);
  }
 else {
    hints.put(Hints.RESOLVE,ResolveValueType.NONE);
  }
  query.setHints(hints);
  query.setProperties(selectedProperties);
  FeatureSource fSource=DataAccessRegistry.getFeatureSource((Name)featureTypeName);
  if (fSource == null) {
    throw new IOException("Internal error: Source could not be found");
  }
  FeatureCollection collection=fSource.getFeatures(query);
  if (!(collection instanceof MappingFeatureCollection)) {
    throw new IOException("Internal error: Mapping feature Collection expected but found " + collection);
  }
  ((MappingFeatureCollection)collection).setUnrolledFilter(instance.baseTableQuery.getFilter());
  FeatureIterator featureIterator=collection.features();
  if (!(featureIterator instanceof DataAccessMappingFeatureIterator)) {
    throw new IOException("Internal error: Data Access Mapping feature Iterator expected but found " + featureIterator);
  }
  DataAccessMappingFeatureIterator daFeatureIterator=(DataAccessMappingFeatureIterator)featureIterator;
  List<Expression> foreignIds=new ArrayList<Expression>();
  for (int i=0; i < query.getQueryJoins().size(); i++) {
    if (query.getQueryJoins().get(i).getIds().isEmpty()) {
      String joinTypeName=query.getQueryJoins().get(i).getJoiningTypeName();
      Expression idValue=filterFac.property(JoiningJDBCFeatureSource.FOREIGN_ID + "_" + i+ "_"+ 0);
      foreignIds.add(filterFac.function("strConcat",filterFac.literal(joinTypeName + "."),idValue));
    }
 else {
      for (int j=0; j < query.getQueryJoins().get(i).getIds().size(); j++) {
        foreignIds.add(filterFac.property(JoiningJDBCFeatureSource.FOREIGN_ID + "_" + i+ "_"+ j));
      }
    }
  }
  daFeatureIterator.setForeignIds(foreignIds);
  instance.featureIterators.put(featureTypeName,daFeatureIterator);
  instance.nestedSourceExpressions.put(featureTypeName,nestedSourceExpression);
  for (  Instance.Skip toSkip : instance.skipped) {
    while (daFeatureIterator.hasNext() && daFeatureIterator.checkForeignIdValues(toSkip.idValues)) {
      daFeatureIterator.skip();
    }
  }
  return daFeatureIterator;
}
