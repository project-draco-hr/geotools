{
  final PlanarImage source=sources[0];
  WritableRectIter iterator=RectIterFactory.createWritable(dest,destRect);
  if (true) {
    iterator=TransfertRectIter.create(RectIterFactory.create(source,destRect),iterator);
  }
  if (!iterator.finishedBands()) {
    for (int i=0; i < bandIndex; i++)     iterator.nextBand();
  }
  double gapsValue=Double.NaN;
  boolean hasGapsValue=false;
  if (this.pieces.hasDefaultValue()) {
    gapsValue=this.pieces.getDefaultValue();
    hasGapsValue=true;
  }
  PiecewiseTransform1DElement last=null;
  final boolean useLast=pieces instanceof DefaultDomain1D;
  do {
    try {
      iterator.startLines();
      if (!iterator.finishedLines())       do {
        iterator.startPixels();
        if (!iterator.finishedPixels())         do {
          final double value=iterator.getSampleDouble();
          final PiecewiseTransform1DElement transform;
          if (useLast) {
            if (last != null && last.contains(value))             transform=last;
 else {
              last=transform=pieces.findDomainElement(value);
            }
          }
 else           transform=(PiecewiseTransform1DElement)pieces.findDomainElement(value);
          if (transform != null)           iterator.setSample(transform.transform(value));
 else {
            if (hasGapsValue)             iterator.setSample(gapsValue);
 else             throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1,Double.toString(value)));
          }
        }
 while (!iterator.nextPixelDone());
      }
 while (!iterator.nextLineDone());
    }
 catch (    Throwable cause) {
      throw new ImagingException(cause.getLocalizedMessage(),cause);
    }
    if (bandIndex != -1)     break;
  }
 while (iterator.finishedBands());
}
