{
  Range[] noData;
  int dataType=sources[0].getSampleModel().getDataType();
  if (noDataUsed) {
switch (dataType) {
case DataBuffer.TYPE_BYTE:
      noData=noDataByte;
    break;
case DataBuffer.TYPE_USHORT:
  noData=noDataUShort;
break;
case DataBuffer.TYPE_SHORT:
noData=noDataShort;
break;
case DataBuffer.TYPE_INT:
noData=noDataInt;
break;
case DataBuffer.TYPE_FLOAT:
noData=noDataFloat;
break;
case DataBuffer.TYPE_DOUBLE:
noData=noDataDouble;
break;
default :
throw new IllegalArgumentException("Wrong data type");
}
}
 else {
noData=null;
}
ROI roi=null;
if (roiUsed) {
roi=roiData;
}
RenderedOp[] translated=new RenderedOp[sources.length];
List<AffineTransform> transform=new ArrayList<AffineTransform>();
for (int i=0; i < sources.length; i++) {
int xTrans=(int)(Math.random() * 10);
int yTrans=(int)(Math.random() * 10);
AffineTransform tr=AffineTransform.getTranslateInstance(xTrans,yTrans);
transform.add(tr);
translated[i]=TranslateDescriptor.create(sources[i],(float)xTrans,(float)yTrans,null,null);
}
ImageLayout layout=new ImageLayout();
layout.setMinX(sources[0].getMinX());
layout.setMinY(sources[0].getMinY());
layout.setWidth(sources[0].getWidth());
layout.setHeight(sources[0].getHeight());
RenderingHints hints=new RenderingHints(JAI.KEY_IMAGE_LAYOUT,layout);
RenderedOp merged=BandMergeDescriptor.create(noData,destNoData,hints,transform,roi,translated);
Assert.assertNotNull(merged.getTiles());
assertEquals(BAND_NUMBER,merged.getNumBands());
int minTileX=merged.getMinTileX();
int minTileY=merged.getMinTileY();
Raster upperLeftTile=merged.getTile(minTileX,minTileY);
int minX=upperLeftTile.getMinX();
int minY=upperLeftTile.getMinY();
int maxX=upperLeftTile.getWidth() + minX;
int maxY=upperLeftTile.getHeight() + minY;
final int dstMinX=merged.getMinX();
final int dstMinY=merged.getMinY();
final int dstMaxX=merged.getMaxX();
final int dstMaxY=merged.getMaxY();
Point2D ptDst=new Point2D.Double(0,0);
Point2D ptSrc=new Point2D.Double(0,0);
for (int b=0; b < BAND_NUMBER; b++) {
RandomIter iter=RandomIterFactory.create(translated[b],null);
final int srcMinX=translated[b].getMinX();
final int srcMinY=translated[b].getMinY();
final int srcMaxX=translated[b].getMaxX();
final int srcMaxY=translated[b].getMaxY();
for (int x=minX; x < maxX; x++) {
for (int y=minY; y < maxY; y++) {
double value=upperLeftTile.getSampleDouble(x,y,b);
if (x < dstMinX || x >= dstMaxX || y < dstMinY || y >= dstMaxY) {
value=destNoData;
}
ptDst.setLocation(x,y);
transform.get(b).transform(ptDst,ptSrc);
int srcX=round(ptSrc.getX());
int srcY=round(ptSrc.getY());
double valueOld=destNoData;
if (!(srcX < srcMinX || srcX >= srcMaxX || srcY < srcMinY || srcY >= srcMaxY)) {
valueOld=iter.getSampleDouble(srcX,srcY,0);
}
boolean contained=true;
if (roiUsed) {
if (!roi.contains(x,y)) {
contained=false;
assertEquals(value,destNoData,TOLERANCE);
}
}
if (contained) {
if (noDataUsed) {
switch (dataType) {
case DataBuffer.TYPE_BYTE:
byte sampleB=ImageUtil.clampRoundByte(value);
byte sampleBOld=ImageUtil.clampRoundByte(valueOld);
if (noData[0].contains(sampleBOld)) {
assertEquals(sampleB,destNoData,TOLERANCE);
}
 else {
assertEquals(sampleB,valueOld,TOLERANCE);
}
break;
case DataBuffer.TYPE_USHORT:
short sampleUS=ImageUtil.clampRoundUShort(value);
short sampleUSOld=ImageUtil.clampRoundUShort(valueOld);
if (noData[0].contains(sampleUSOld)) {
assertEquals(sampleUS,destNoData,TOLERANCE);
}
 else {
assertEquals(sampleUS,valueOld,TOLERANCE);
}
break;
case DataBuffer.TYPE_SHORT:
short sampleS=ImageUtil.clampRoundShort(value);
short sampleSOld=ImageUtil.clampRoundShort(valueOld);
if (noData[0].contains(sampleSOld)) {
assertEquals(sampleS,destNoData,TOLERANCE);
}
 else {
assertEquals(sampleS,valueOld,TOLERANCE);
}
break;
case DataBuffer.TYPE_INT:
int sampleI=ImageUtil.clampRoundInt(value);
int sampleIOld=ImageUtil.clampRoundInt(valueOld);
if (noData[0].contains(sampleIOld)) {
assertEquals(sampleI,destNoData,TOLERANCE);
}
 else {
assertEquals(sampleI,valueOld,TOLERANCE);
}
break;
case DataBuffer.TYPE_FLOAT:
float sampleF=ImageUtil.clampFloat(value);
float sampleFOld=ImageUtil.clampFloat(valueOld);
if (noData[0].contains(sampleFOld)) {
assertEquals(sampleF,destNoData,TOLERANCE);
}
 else {
assertEquals(sampleF,valueOld,TOLERANCE);
}
break;
case DataBuffer.TYPE_DOUBLE:
if (noData[0].contains(valueOld)) {
assertEquals(value,destNoData,TOLERANCE);
}
 else {
assertEquals(value,valueOld,TOLERANCE);
}
break;
default :
throw new IllegalArgumentException("Wrong data type");
}
}
 else {
assertEquals(value,valueOld,TOLERANCE);
}
}
}
}
}
merged.dispose();
}
