{
  int size=Math.max(image.getWidth(),image.getHeight());
  boolean hasScaleX=Math.abs(tx.getScaleX() - 1) * size > RS_EPS;
  boolean hasScaleY=Math.abs(tx.getScaleY() - 1) * size > RS_EPS;
  boolean hasShearX=Math.abs(tx.getShearX()) * size > RS_EPS;
  boolean hasShearY=Math.abs(tx.getShearY()) * size > RS_EPS;
  boolean hasTranslateX=Math.abs(tx.getTranslateX()) > RS_EPS;
  boolean hasTranslateY=Math.abs(tx.getTranslateY()) > RS_EPS;
  if (!hasScaleX && !hasScaleY && !hasShearX&& !hasShearY&& !hasTranslateX&& !hasTranslateY) {
    return this;
  }
  ParameterListDescriptor pld=new AffineDescriptor().getParameterListDescriptor(RenderedRegistryMode.MODE_NAME);
  if (interpolation == null) {
    interpolation=(Interpolation)pld.getParamDefaultValue("interpolation");
  }
  if (bgValues == null) {
    bgValues=(double[])pld.getParamDefaultValue("backgroundValues");
  }
  RenderedImage source=image;
  if (image instanceof RenderedOp) {
    RenderedOp op=(RenderedOp)image;
    Object mtProperty=op.getProperty("MathTransform");
    Object sourceBoundsProperty=op.getProperty("SourceBoundingBox");
    String opName=op.getOperationName();
    if (WARP_REDUCTION_ENABLED && "Warp".equals(opName) && mtProperty instanceof MathTransform2D&& sourceBoundsProperty instanceof Rectangle) {
      try {
        MathTransform2D originalTransform=(MathTransform2D)mtProperty;
        MathTransformFactory factory=ReferencingFactoryFinder.getMathTransformFactory(null);
        MathTransform affineMT=factory.createAffineTransform(new org.geotools.referencing.operation.matrix.AffineTransform2D(tx));
        MathTransform2D chained=(MathTransform2D)factory.createConcatenatedTransform(affineMT.inverse(),originalTransform);
        Double tolerance=(Double)getRenderingHint(Hints.RESAMPLE_TOLERANCE);
        if (tolerance == null) {
          tolerance=(Double)Hints.getSystemDefault(Hints.RESAMPLE_TOLERANCE);
        }
        if (tolerance == null) {
          tolerance=0.333;
        }
        WarpBuilder wb=new WarpBuilder(tolerance);
        wb.setMaxPositions(4 * 1024 * 1024);
        RenderedOp at=AffineDescriptor.create(source,tx,interpolation,bgValues,commonHints);
        Rectangle targetBB=at.getBounds();
        at.dispose();
        Rectangle sourceBB=(Rectangle)sourceBoundsProperty;
        Rectangle mappingBB;
        if (source.getProperty("ROI") instanceof ROI) {
          mappingBB=sourceBB.union(targetBB);
        }
 else {
          mappingBB=targetBB;
        }
        Warp warp=wb.buildWarp(chained,mappingBB);
        Warp sourceWarp=(Warp)op.getParameterBlock().getObjectParameter(0);
        if (warp instanceof WarpGrid || warp instanceof WarpAffine || !(sourceWarp instanceof WarpGrid || sourceWarp instanceof WarpAffine)) {
          PlanarImage sourceImage=op.getSourceImage(0);
          final ParameterBlock paramBlk=new ParameterBlock().addSource(sourceImage);
          Object property=sourceImage.getProperty("ROI");
          if ((property == null) || property.equals(java.awt.Image.UndefinedProperty) || !(property instanceof ROI)) {
            paramBlk.add(warp).add(interpolation).add(bgValues);
          }
 else {
            paramBlk.add(warp).add(interpolation).add(bgValues).add((ROI)property);
          }
          Hints localHints=new Hints(commonHints);
          localHints.remove(JAI.KEY_IMAGE_LAYOUT);
          ImageLayout il=new ImageLayout();
          il.setMinX(targetBB.x);
          il.setMinY(targetBB.y);
          il.setWidth(targetBB.width);
          il.setHeight(targetBB.height);
          localHints.put(JAI.KEY_IMAGE_LAYOUT,il);
          RenderedOp result=JAI.create("Warp",paramBlk,localHints);
          result.setProperty("MathTransform",chained);
          image=result;
          return this;
        }
      }
 catch (      Exception e) {
        LOGGER.log(Level.WARNING,"Failed to squash warp and affine into a single operation, chaining them instead",e);
      }
    }
    if ("Affine".equals(opName)) {
      ParameterBlock paramBlock=op.getParameterBlock();
      RenderedImage sSource=paramBlock.getRenderedSource(0);
      AffineTransform sTx=(AffineTransform)paramBlock.getObjectParameter(0);
      Interpolation sInterp=(Interpolation)paramBlock.getObjectParameter(1);
      double[] sBgValues=(double[])paramBlock.getObjectParameter(2);
      if ((sInterp == interpolation && Arrays.equals(sBgValues,bgValues))) {
        AffineTransform concat=new AffineTransform(tx);
        concat.concatenate(sTx);
        tx=concat;
        source=sSource;
      }
    }
 else     if ("Scale".equals(opName)) {
      ParameterBlock paramBlock=op.getParameterBlock();
      RenderedImage sSource=paramBlock.getRenderedSource(0);
      float xScale=paramBlock.getFloatParameter(0);
      float yScale=paramBlock.getFloatParameter(1);
      float xTrans=paramBlock.getFloatParameter(2);
      float yTrans=paramBlock.getFloatParameter(3);
      Interpolation sInterp=(Interpolation)paramBlock.getObjectParameter(4);
      if (sInterp == interpolation) {
        AffineTransform concat=new AffineTransform(tx);
        concat.concatenate(new AffineTransform(xScale,0,0,yScale,xTrans,yTrans));
        tx=concat;
        source=sSource;
      }
    }
  }
  hasScaleX=Math.abs(tx.getScaleX() - 1) * size > RS_EPS;
  hasScaleY=Math.abs(tx.getScaleY() - 1) * size > RS_EPS;
  hasShearX=Math.abs(tx.getShearX()) * size > RS_EPS;
  hasShearY=Math.abs(tx.getShearY()) * size > RS_EPS;
  hasTranslateX=Math.abs(tx.getTranslateX()) > RS_EPS;
  hasTranslateY=Math.abs(tx.getTranslateY()) > RS_EPS;
  boolean intTranslateX=Math.abs((tx.getTranslateX() - Math.round(tx.getTranslateX()))) < RS_EPS;
  boolean intTranslateY=Math.abs((tx.getTranslateY() - Math.round(tx.getTranslateY()))) < RS_EPS;
  if (!hasScaleX && !hasScaleY && !hasShearX&& !hasShearY&& !hasTranslateX&& !hasTranslateY) {
    this.image=source;
    return this;
  }
  if (!hasShearX && !hasShearY) {
    if (!hasScaleX && !hasScaleY && intTranslateX&& intTranslateY) {
      Hints localHints=new Hints(commonHints);
      localHints.remove(JAI.KEY_IMAGE_LAYOUT);
      image=ScaleDescriptor.create(source,1.0f,1.0f,(float)Math.round(tx.getTranslateX()),(float)Math.round(tx.getTranslateY()),interpolation,localHints);
    }
 else {
      image=ScaleDescriptor.create(source,(float)tx.getScaleX(),(float)tx.getScaleY(),(float)tx.getTranslateX(),(float)tx.getTranslateY(),interpolation,commonHints);
    }
  }
 else {
    image=AffineDescriptor.create(source,tx,interpolation,bgValues,commonHints);
  }
  return this;
}
