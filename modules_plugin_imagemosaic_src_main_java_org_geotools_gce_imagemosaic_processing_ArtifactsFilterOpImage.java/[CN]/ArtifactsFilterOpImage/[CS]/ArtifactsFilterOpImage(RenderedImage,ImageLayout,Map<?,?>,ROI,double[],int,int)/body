{
  super(source,layout,config,true);
  RenderedImage inputRI=source;
  iter=RandomIterFactory.create(inputRI,null);
  final int tr=inputRI.getColorModel().getTransparency();
  this.numBands=sampleModel.getNumBands();
  this.filterSize=filterSize;
  ROI thresholdRoi=null;
  ROI zeroRoi=null;
  if (sourceROI != null) {
    RenderedImage image=inputRI;
    if (threshold != Integer.MAX_VALUE) {
      if (numBands == 3) {
        image=BandCombineDescriptor.create(image,RGB_TO_GRAY_MATRIX,null);
      }
 else {
        final double fillValue=tr == Transparency.OPAQUE ? 1.0 / numBands : 1.0 / (numBands - 1);
        final double[][] matrix=new double[1][numBands + 1];
        for (int i=0; i < numBands; i++) {
          matrix[0][i]=fillValue;
        }
        image=BandCombineDescriptor.create(image,matrix,null);
      }
      thresholdRoi=new ROI(image,threshold);
      thresholdRoi=thresholdRoi.intersect(sourceROI);
      zeroRoi=new ROI(image,1);
    }
  }
  this.backgroundValues=new double[numBands];
  if (backgroundValues == null) {
    backgroundValues=new double[]{0.0};
  }
  if (backgroundValues.length < numBands) {
    Arrays.fill(this.backgroundValues,backgroundValues[0]);
  }
 else {
    System.arraycopy(backgroundValues,0,this.backgroundValues,0,numBands);
  }
  final int dataType=sampleModel.getDataType();
  double sourceExtensionConstant;
switch (dataType) {
case DataBuffer.TYPE_BYTE:
    sourceExtensionConstant=0.0;
  break;
case DataBuffer.TYPE_USHORT:
sourceExtensionConstant=0.0;
break;
case DataBuffer.TYPE_SHORT:
sourceExtensionConstant=Short.MIN_VALUE;
break;
case DataBuffer.TYPE_INT:
sourceExtensionConstant=Integer.MIN_VALUE;
break;
case DataBuffer.TYPE_FLOAT:
sourceExtensionConstant=-Float.MAX_VALUE;
break;
case DataBuffer.TYPE_DOUBLE:
default :
sourceExtensionConstant=-Double.MAX_VALUE;
}
this.sourceExtender=sourceExtensionConstant == 0.0 ? BorderExtender.createInstance(BorderExtender.BORDER_ZERO) : new BorderExtenderConstant(new double[]{sourceExtensionConstant});
if (sourceROI != null) {
final PlanarImage roiImage=sourceROI.getAsImage();
final RandomIter roiIter=RandomIterFactory.create(roiImage,null);
final int minRoiX=roiImage.getMinX();
final int minRoiY=roiImage.getMinY();
final int roiW=roiImage.getWidth();
final int roiH=roiImage.getHeight();
roiAccessor=new RoiAccessor(roiIter,sourceROI,roiImage,minRoiX,minRoiY,roiW,roiH);
}
if (thresholdRoi != null) {
final PlanarImage thresholdRoiImage=thresholdRoi.getAsImage();
final RandomIter thresholdRoiIter=RandomIterFactory.create(thresholdRoiImage,null);
final int minRoiThX=thresholdRoiImage.getMinX();
final int minRoiThY=thresholdRoiImage.getMinY();
final int roiThW=thresholdRoiImage.getWidth();
final int roiThH=thresholdRoiImage.getHeight();
thresholdRoiAccessor=new RoiAccessor(thresholdRoiIter,thresholdRoi,thresholdRoiImage,minRoiThX,minRoiThY,roiThW,roiThH);
}
if (zeroRoi != null) {
final PlanarImage zeroRoiImage=zeroRoi.getAsImage();
final RandomIter zeroRoiIter=RandomIterFactory.create(zeroRoiImage,null);
final int minX=zeroRoiImage.getMinX();
final int minY=zeroRoiImage.getMinY();
final int w=zeroRoiImage.getWidth();
final int h=zeroRoiImage.getHeight();
zeroRoiAccessor=new RoiAccessor(zeroRoiIter,zeroRoi,zeroRoiImage,minX,minY,w,h);
}
}
