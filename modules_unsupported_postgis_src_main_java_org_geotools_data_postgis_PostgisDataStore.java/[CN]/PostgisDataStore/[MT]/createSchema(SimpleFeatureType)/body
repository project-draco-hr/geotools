{
  String tableName=featureType.getTypeName();
  String lcTableName=tableName.toLowerCase();
  AttributeDescriptor[] attributeType=(AttributeDescriptor[])featureType.getAttributeDescriptors().toArray(new AttributeDescriptor[featureType.getAttributeDescriptors().size()]);
  String dbSchema=config.getDatabaseSchemaName();
  PostgisSQLBuilder sqlb=createSQLBuilder();
  String fidColumn=lcTableName + "_fid";
  for (int i=0; i < attributeType.length; i++) {
    if (attributeType[i].getLocalName().equalsIgnoreCase(fidColumn)) {
      String message="The featuretype cannot contain the column " + fidColumn + ", since this is used as the hidden FID column";
      throw new IOException(message);
    }
  }
  Connection con=this.getConnection(Transaction.AUTO_COMMIT);
  Statement st=null;
  boolean shouldExecute=!tablePresent(tableName,con);
  try {
    con.setAutoCommit(false);
    st=con.createStatement();
    StringBuffer sql=new StringBuffer("CREATE TABLE ");
    sql.append(sqlb.encodeTableName(tableName));
    sql.append(" (");
    sql.append(sqlb.encodeColumnName(fidColumn));
    sql.append(" serial PRIMARY KEY,");
    sql.append(makeSqlCreate(attributeType));
    sql.append(");");
    String sqlStr=sql.toString();
    LOGGER.info(sqlStr);
    if (shouldExecute) {
      st.execute(sqlStr);
    }
    sql=new StringBuffer("DELETE FROM GEOMETRY_COLUMNS WHERE f_table_catalog=''");
    sql.append(" AND f_table_schema = '");
    sql.append(dbSchema);
    sql.append("'");
    sql.append("AND f_table_name = '");
    sql.append(tableName);
    sql.append("';");
    sqlStr=sql.toString();
    LOGGER.info(sqlStr);
    if (shouldExecute) {
      st.execute(sqlStr);
    }
    for (int i=0; i < attributeType.length; i++) {
      if (!(attributeType[i] instanceof GeometryDescriptor)) {
        continue;
      }
      GeometryDescriptor geomAttribute=(GeometryDescriptor)attributeType[i];
      String columnName=attributeType[i].getLocalName();
      CoordinateReferenceSystem refSys=geomAttribute.getCoordinateReferenceSystem();
      int SRID;
      if (refSys != null) {
        try {
          Set ident=refSys.getIdentifiers();
          if ((ident == null || ident.isEmpty()) && refSys == DefaultGeographicCRS.WGS84) {
            SRID=4326;
          }
 else {
            String code=((NamedIdentifier)ident.toArray()[0]).getCode();
            SRID=Integer.parseInt(code);
          }
        }
 catch (        Exception e) {
          LOGGER.warning("SRID could not be determined");
          SRID=-1;
        }
      }
 else {
        SRID=-1;
      }
      String typeName=null;
      Class type=geomAttribute.getType().getBinding();
      int dimension=2;
      typeName=getGeometrySQLTypeName(type);
      GeometryDescriptor gd=(GeometryDescriptor)geomAttribute;
      if (gd.getUserData().get(Hints.COORDINATE_DIMENSION) instanceof Integer) {
        dimension=(Integer)gd.getUserData().get(Hints.COORDINATE_DIMENSION);
      }
      if (typeName != null) {
        sql=new StringBuffer("INSERT INTO GEOMETRY_COLUMNS VALUES (");
        sql.append("'','");
        sql.append(dbSchema);
        sql.append("','");
        sql.append(tableName);
        sql.append("','");
        sql.append(columnName);
        sql.append("',");
        sql.append(dimension);
        sql.append(",");
        sql.append(SRID);
        sql.append(",'");
        sql.append(typeName);
        sql.append("');");
        sqlStr=sql.toString();
        LOGGER.info(sqlStr);
        if (shouldExecute) {
          st.execute(sqlStr);
        }
        if (SRID > -1) {
          sql=new StringBuffer("ALTER TABLE ");
          sql.append(sqlb.encodeTableName(tableName));
          sql.append(" ADD CONSTRAINT enforce_srid_");
          sql.append(columnName);
          sql.append(" CHECK (SRID(");
          sql.append(sqlb.encodeColumnName(columnName));
          sql.append(") = ");
          sql.append(SRID);
          sql.append(");");
          sqlStr=sql.toString();
          LOGGER.info(sqlStr);
          if (shouldExecute) {
            st.execute(sqlStr);
          }
        }
        sql=new StringBuffer("ALTER TABLE ");
        sql.append(sqlb.encodeTableName(tableName));
        sql.append(" ADD CONSTRAINT enforce_dims_");
        sql.append(columnName);
        sql.append(" CHECK (ndims(");
        sql.append(sqlb.encodeColumnName(columnName));
        sql.append(") = ");
        sql.append(dimension);
        sql.append(");");
        sqlStr=sql.toString();
        LOGGER.info(sqlStr);
        if (shouldExecute) {
          st.execute(sqlStr);
        }
        if (!typeName.equals("GEOMETRY")) {
          sql=new StringBuffer("ALTER TABLE ");
          sql.append(sqlb.encodeTableName(tableName));
          sql.append(" ADD CONSTRAINT enforce_geotype_");
          sql.append(columnName);
          sql.append(" CHECK (geometrytype(");
          sql.append(sqlb.encodeColumnName(columnName));
          sql.append(") = '");
          sql.append(typeName);
          sql.append("'::text OR ");
          sql.append(sqlb.encodeColumnName(columnName));
          sql.append(" IS NULL);");
          sqlStr=sql.toString();
          LOGGER.info(sqlStr);
          if (shouldExecute) {
            st.execute(sqlStr);
          }
        }
      }
 else {
        LOGGER.warning("Error: " + geomAttribute.getLocalName() + " unknown type!!!");
      }
      sql=new StringBuffer("CREATE INDEX spatial_");
      sql.append(tableName);
      sql.append("_");
      sql.append(attributeType[i].getLocalName().toLowerCase());
      sql.append(" ON ");
      sql.append(sqlb.encodeTableName(tableName));
      sql.append(" USING GIST (");
      sql.append(sqlb.encodeColumnName(attributeType[i].getLocalName()));
      sql.append(");");
      sqlStr=sql.toString();
      LOGGER.info(sqlStr);
      if (shouldExecute) {
        st.execute(sqlStr);
      }
    }
    con.commit();
  }
 catch (  SQLException e) {
    try {
      if (con != null) {
        con.rollback();
      }
    }
 catch (    SQLException sqle) {
      throw new IOException(sqle.getMessage());
    }
    throw (IOException)new IOException(e.getMessage()).initCause(e);
  }
 finally {
    try {
      if (st != null) {
        st.close();
      }
    }
 catch (    SQLException e) {
      throw new IOException(e.getMessage());
    }
 finally {
      try {
        if (con != null) {
          con.setAutoCommit(true);
          con.close();
        }
      }
 catch (      SQLException e) {
        throw new IOException(e.getMessage());
      }
    }
  }
  if (!shouldExecute) {
    throw new IOException("The table " + tableName + " already exists.");
  }
}
