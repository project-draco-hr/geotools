{
  Date start=new Date();
  Connection con=null;
  List<ImageDecoderThread> threads=new ArrayList<ImageDecoderThread>();
  ExecutorService pool=getExecutorServivicePool();
  String gridStatement=statementMap.get(levelInfo);
  try {
    con=getConnection();
    PreparedStatement s=con.prepareStatement(gridStatement);
    WKBWriter w=new WKBWriter();
    byte[] bytes=w.write(polyFromEnvelope(requestEnvelope));
    s.setBytes(1,bytes);
    s.setInt(2,levelInfo.getSrsId());
    ResultSet r=s.executeQuery();
    while (r.next()) {
      byte[] tileBytes=r.getBytes(2);
      byte[] envBytes=r.getBytes(1);
      WKBReader reader=new WKBReader();
      Geometry g;
      try {
        g=reader.read(envBytes);
      }
 catch (      ParseException e) {
        LOGGER.log(Level.SEVERE,e.getMessage(),e);
        throw new IOException(e);
      }
      Envelope env=g.getEnvelopeInternal();
      Rectangle2D tmp=new Rectangle2D.Double(env.getMinX(),env.getMinY(),env.getWidth(),env.getHeight());
      GeneralEnvelope tileGeneralEnvelope=new GeneralEnvelope(tmp);
      tileGeneralEnvelope.setCoordinateReferenceSystem(requestEnvelope.getCoordinateReferenceSystem());
      ImageDecoderThread thread=new ImageDecoderThread(tileBytes,"",tileGeneralEnvelope,pixelDimension,requestEnvelope,levelInfo,tileQueue,getConfig());
      threads.add(thread);
      pool.execute(thread);
    }
    r.close();
    s.close();
    con.close();
  }
 catch (  SQLException e) {
    try {
      con.close();
    }
 catch (    SQLException e1) {
    }
    LOGGER.log(Level.SEVERE,e.getMessage(),e);
    throw new IOException(e);
  }
  if (LOGGER.isLoggable(Level.INFO))   LOGGER.info("Getting " + threads.size() + " Tiles needs "+ ((new Date()).getTime() - start.getTime())+ " millisecs");
  pool.shutdown();
  try {
    pool.awaitTermination(3600,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e.getLocalizedMessage());
  }
  tileQueue.add(TileQueueElement.ENDELEMENT);
  if (LOGGER.isLoggable(Level.INFO))   LOGGER.info("Getting and decoding  " + threads.size() + " Tiles needs "+ ((new Date()).getTime() - start.getTime())+ " millisecs");
}
