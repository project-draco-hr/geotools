{
  return new PathIterator(){
    int currentPart=0;
    int currentIndex=0;
    public int getWindingRule(){
      return WIND_NON_ZERO;
    }
    public boolean isDone(){
      return currentPart == geom.coords.length;
    }
    public void next(){
      if (isDone()) {
        return;
      }
      if ((currentIndex + 1) >= geom.coords[currentPart].length) {
        currentIndex=0;
        currentPart++;
      }
 else {
        currentIndex++;
      }
    }
    public int currentSegment(    float[] coords){
      if (currentIndex == 0) {
        coords[0]=(float)geom.coords[currentPart][currentIndex];
        currentIndex++;
        coords[1]=(float)geom.coords[currentPart][currentIndex];
        if (at != null) {
          at.transform(coords,0,coords,0,1);
        }
        return SEG_MOVETO;
      }
 else {
        coords[0]=(float)geom.coords[currentPart][currentIndex];
        currentIndex++;
        coords[1]=(float)geom.coords[currentPart][currentIndex];
        if (at != null) {
          at.transform(coords,0,coords,0,1);
        }
        return SEG_LINETO;
      }
    }
    public int currentSegment(    double[] coords){
      if (currentIndex == 0) {
        coords[0]=(float)geom.coords[currentPart][currentIndex];
        currentIndex++;
        coords[1]=(float)geom.coords[currentPart][currentIndex];
        if (at != null) {
          at.transform(coords,0,coords,0,1);
        }
        return SEG_MOVETO;
      }
 else {
        coords[0]=(float)geom.coords[currentPart][currentIndex];
        currentIndex++;
        coords[1]=(float)geom.coords[currentPart][currentIndex];
        if (at != null) {
          at.transform(coords,0,coords,0,1);
        }
        return SEG_LINETO;
      }
    }
  }
;
}
