{
  if (type == ShapeType.NULL) {
    return null;
  }
  Envelope geomBBox=GeometryHandlerUtilities.readBounds(buffer);
  if (!bbox.intersects(geomBBox)) {
    return null;
  }
  boolean bboxdecimate=(geomBBox.getWidth() <= span.getX()) && (geomBBox.getHeight() <= span.getY());
  int numParts=buffer.getInt();
  int numPoints=buffer.getInt();
  int[] partOffsets=new int[numParts];
  for (int i=0; i < numParts; i++) {
    partOffsets[i]=buffer.getInt();
  }
  double[][] coords=new double[numParts][];
  double[][] transformed=new double[numParts][];
  int finish;
  int start=0;
  int length=0;
  if (bboxdecimate) {
    coords=new double[1][];
    coords[0]=new double[4];
    transformed=new double[1][];
    transformed[0]=new double[4];
    coords[0][0]=buffer.getDouble();
    coords[0][1]=buffer.getDouble();
    buffer.position((buffer.position() + ((numPoints - 2) * 16)));
    coords[0][2]=buffer.getDouble();
    coords[0][3]=buffer.getDouble();
    if (!bbox.contains(coords[0][0],coords[0][1]) && !bbox.contains(coords[0][2],coords[0][3])) {
      return null;
    }
    try {
      mt.transform(coords[0],0,transformed[0],0,1);
      if (screenMap.checkAndSet((int)transformed[0][0],(int)transformed[0][1])) {
        return null;
      }
      mt.transform(coords[0],2,transformed[0],2,1);
      double minx=(int)transformed[0][0];
      double miny=(int)transformed[0][1];
      double maxx=minx + 1;
      double maxy=transformed[0][3];
      transformed[0][0]=minx;
      transformed[0][1]=miny;
      transformed[0][2]=maxx;
      transformed[0][3]=maxy;
    }
 catch (    Exception e) {
      ShapefileRenderer.LOGGER.severe("could not transform coordinates " + e.getLocalizedMessage());
      transformed[0]=coords[0];
    }
  }
 else {
    boolean intersection=false;
    int partsInBBox=0;
    for (int part=0; part < numParts; part++) {
      intersection=false;
      start=partOffsets[part];
      if (part == (numParts - 1)) {
        finish=numPoints;
      }
 else {
        finish=partOffsets[part + 1];
      }
      length=finish - start;
      coords[part]=new double[length * 2];
      int readDoubles=0;
      int currentDoubles=0;
      int totalDoubles=length * 2;
      while (currentDoubles < totalDoubles) {
        coords[part][readDoubles]=buffer.getDouble();
        readDoubles++;
        currentDoubles++;
        coords[part][readDoubles]=buffer.getDouble();
        readDoubles++;
        currentDoubles++;
        intersection=bboxIntersectSegment(intersection,coords[part],readDoubles);
        if ((readDoubles > 3) && (currentDoubles < (totalDoubles - 1))) {
          if ((Math.abs(coords[part][readDoubles - 4] - coords[part][readDoubles - 2]) <= span.getX()) && (Math.abs(coords[part][readDoubles - 3] - coords[part][readDoubles - 1]) <= span.getY())) {
            readDoubles-=2;
          }
        }
      }
      if (!intersection) {
        continue;
      }
      if (!mt.isIdentity()) {
        try {
          transformed[partsInBBox]=new double[readDoubles];
          GeometryHandlerUtilities.transform(type,mt,coords[part],transformed[partsInBBox],readDoubles / 2);
        }
 catch (        Exception e) {
          ShapefileRenderer.LOGGER.severe("could not transform coordinates " + e.getLocalizedMessage());
          transformed[partsInBBox]=coords[part];
        }
      }
 else {
        transformed[partsInBBox]=new double[readDoubles];
        System.arraycopy(coords[part],0,transformed[partsInBBox],0,readDoubles / 2);
      }
      partsInBBox++;
    }
    if (partsInBBox == 0) {
      return null;
    }
    if (partsInBBox != numParts) {
      double[][] tmp=new double[partsInBBox][];
      System.arraycopy(transformed,0,tmp,0,partsInBBox);
      transformed=tmp;
    }
  }
  return createGeometry(type,geomBBox,transformed);
}
