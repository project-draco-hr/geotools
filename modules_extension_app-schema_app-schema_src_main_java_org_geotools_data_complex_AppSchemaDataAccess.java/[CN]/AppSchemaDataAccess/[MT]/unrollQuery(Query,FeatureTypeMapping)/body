{
  Query unrolledQuery=Query.ALL;
  FeatureSource source=mapping.getSource();
  if (!Query.ALL.equals(query)) {
    Filter complexFilter=query.getFilter();
    Filter unrolledFilter=AppSchemaDataAccess.unrollFilter(complexFilter,mapping);
    Object includeProps=query.getHints().get(Query.INCLUDE_MANDATORY_PROPS);
    List<PropertyName> propNames=getSurrogatePropertyNames(query.getProperties(),mapping,includeProps instanceof Boolean && ((Boolean)includeProps).booleanValue());
    Query newQuery=new Query();
    String name=source.getName().getLocalPart();
    newQuery.setTypeName(name);
    newQuery.setFilter(unrolledFilter);
    newQuery.setProperties(propNames);
    newQuery.setCoordinateSystem(query.getCoordinateSystem());
    newQuery.setCoordinateSystemReproject(query.getCoordinateSystemReproject());
    newQuery.setHandle(query.getHandle());
    newQuery.setMaxFeatures(query.getMaxFeatures());
    List<SortBy> sort=new ArrayList<SortBy>();
    if (query.getSortBy() != null) {
      for (      SortBy sortBy : query.getSortBy()) {
        for (        Expression expr : unrollProperty(sortBy.getPropertyName(),mapping)) {
          if (expr != null) {
            FilterAttributeExtractor extractor=new FilterAttributeExtractor();
            expr.accept(extractor,null);
            for (            String att : extractor.getAttributeNameSet()) {
              sort.add(new SortByImpl(filterFac.property(att),sortBy.getSortOrder()));
            }
          }
        }
      }
    }
    if (query instanceof JoiningQuery) {
      FilterAttributeExtractor extractor=new FilterAttributeExtractor();
      mapping.getFeatureIdExpression().accept(extractor,null);
      if (!Expression.NIL.equals(mapping.getFeatureIdExpression()) && !(mapping.getFeatureIdExpression() instanceof Literal) && extractor.getAttributeNameSet().isEmpty()) {
        String ns=mapping.namespaces.getPrefix(mapping.getTargetFeature().getName().getNamespaceURI());
        String separator=mapping.getTargetFeature().getName().getSeparator();
        String typeName=mapping.getTargetFeature().getLocalName();
        throw new UnsupportedOperationException(String.format("idExpression '%s' for targetElement '%s%s%s' cannot be translated into SQL, " + "therefore is not supported with joining!" + "\nPlease make sure idExpression is mapped into existing database fields, "+ "and only use functions that are supported by your database."+ "\nIf this cannot be helped, you can turn off joining in app-schema.properties file.",mapping.getFeatureIdExpression(),ns,separator,typeName));
      }
      for (      String att : extractor.getAttributeNameSet()) {
        sort.add(new SortByImpl(filterFac.property(att),SortOrder.ASCENDING));
      }
      JoiningQuery jQuery=new JoiningQuery(newQuery,(!Expression.NIL.equals(mapping.getFeatureIdExpression()) && !(mapping.getFeatureIdExpression() instanceof Literal)));
      jQuery.setQueryJoins(((JoiningQuery)query).getQueryJoins());
      jQuery.setSubset(((JoiningQuery)query).isSubset());
      unrolledQuery=jQuery;
    }
 else {
      unrolledQuery=newQuery;
    }
    unrolledQuery.setSortBy(sort.toArray(new SortBy[sort.size()]));
  }
  return unrolledQuery;
}
