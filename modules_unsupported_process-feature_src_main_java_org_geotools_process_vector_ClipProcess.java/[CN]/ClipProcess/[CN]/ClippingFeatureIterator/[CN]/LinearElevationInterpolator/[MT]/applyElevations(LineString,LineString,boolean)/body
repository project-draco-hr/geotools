{
  if (!hasElevations(original.getCoordinateSequence())) {
    return;
  }
  CoordinateSequence cs=ls.getCoordinateSequence();
  CoordinateSequence csOrig=original.getCoordinateSequence();
  Coordinate c1=cs.getCoordinate(0);
  Coordinate c2=cs.getCoordinate(1);
  int localIdx=0;
  Coordinate o1=csOrig.getCoordinate(0);
  Coordinate o2=csOrig.getCoordinate(1);
  int origIdx=0;
  RobustLineIntersector intersector=new RobustLineIntersector();
  int matched=0;
  boolean flipped=false;
  for (; ; ) {
    intersector.computeIntersection(c1,c2,o1,o2);
    int intersectionNum=intersector.getIntersectionNum();
    if (intersectionNum == LineIntersector.POINT_INTERSECTION || (tolerant && intersectionNum != LineIntersector.COLLINEAR)) {
      LineSegment segment=new LineSegment(o1,o2);
      double d1=segment.distance(c1);
      double d2=segment.distance(c2);
      if (d1 <= PointDistance.EPS_METERS && d2 <= PointDistance.EPS_METERS) {
        intersectionNum=LineIntersector.COLLINEAR;
      }
    }
    if (intersectionNum == LineIntersector.COLLINEAR) {
      matched++;
      applyZValues(cs,localIdx,csOrig,origIdx);
      localIdx++;
      if (localIdx == cs.size() - 1) {
        applyZValues(cs,localIdx,csOrig,origIdx);
        break;
      }
 else {
        c1=c2;
        c2=cs.getCoordinate(localIdx + 1);
      }
    }
 else {
      origIdx++;
      if (origIdx >= csOrig.size() - 1) {
        if (!flipped) {
          ls=(LineString)ls.reverse();
          cs=ls.getCoordinateSequence();
          flipped=true;
          c1=cs.getCoordinate(0);
          c2=cs.getCoordinate(1);
          localIdx=0;
          o1=csOrig.getCoordinate(0);
          o2=csOrig.getCoordinate(1);
          origIdx=0;
        }
 else {
          throw new ClippingException("Could not find collinear segments between " + ls.toText() + "\n and \n"+ original.toText()+ "\n after matching "+ matched+ " points");
        }
      }
 else {
        o1=o2;
        o2=csOrig.getCoordinate(origIdx + 1);
      }
    }
  }
}
