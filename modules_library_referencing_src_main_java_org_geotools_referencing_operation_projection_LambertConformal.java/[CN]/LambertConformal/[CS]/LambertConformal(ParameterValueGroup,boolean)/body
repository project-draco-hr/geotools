{
  super(parameters);
  final Collection<GeneralParameterDescriptor> expected=getParameterDescriptors().descriptors();
  final boolean sp2=expected.contains(AbstractProvider.STANDARD_PARALLEL_2);
  this.belgium=belgium;
  if (sp2) {
    double phi2;
    phi1=doubleValue(expected,AbstractProvider.STANDARD_PARALLEL_1,parameters);
    ensureLatitudeInRange(AbstractProvider.STANDARD_PARALLEL_1,phi1,true);
    phi2=doubleValue(expected,AbstractProvider.STANDARD_PARALLEL_2,parameters);
    if (Double.isNaN(phi2)) {
      phi2=phi1;
    }
    this.phi2=phi2;
    ensureLatitudeInRange(AbstractProvider.STANDARD_PARALLEL_2,phi2,true);
  }
 else {
    if (belgium) {
      throw new IllegalArgumentException();
    }
    phi1=phi2=latitudeOfOrigin;
  }
  if (abs(phi1 + phi2) < EPSILON) {
    throw new IllegalArgumentException(Errors.format(ErrorKeys.ANTIPODE_LATITUDES_$2,new Latitude(toDegrees(phi1)),new Latitude(toDegrees(phi2))));
  }
  final double cosphi1=cos(phi1);
  final double sinphi1=sin(phi1);
  final boolean secant=abs(phi1 - phi2) > EPSILON;
  if (isSpherical) {
    if (secant) {
      n=log(cosphi1 / cos(phi2)) / log(tan(PI / 4 + 0.5 * phi2) / tan(PI / 4 + 0.5 * phi1));
    }
 else {
      n=sinphi1;
    }
    F=cosphi1 * pow(tan(PI / 4 + 0.5 * phi1),n) / n;
    if (abs(abs(latitudeOfOrigin) - PI / 2) >= EPSILON) {
      rho0=F * pow(tan(PI / 4 + 0.5 * latitudeOfOrigin),-n);
    }
 else {
      rho0=0.0;
    }
  }
 else {
    final double m1=msfn(sinphi1,cosphi1);
    final double t1=tsfn(phi1,sinphi1);
    if (secant) {
      final double sinphi2=sin(phi2);
      final double m2=msfn(sinphi2,cos(phi2));
      final double t2=tsfn(phi2,sinphi2);
      n=log(m1 / m2) / log(t1 / t2);
    }
 else {
      n=sinphi1;
    }
    F=m1 * pow(t1,-n) / n;
    if (abs(abs(latitudeOfOrigin) - PI / 2) >= EPSILON) {
      rho0=F * pow(tsfn(latitudeOfOrigin,sin(latitudeOfOrigin)),n);
    }
 else {
      rho0=0.0;
    }
  }
}
