{
  String t_datumName=new Identification("ISO8601",null,null,null).getName();
  TemporalCRS temporalCRS=null;
  try {
    if (timeAxis != null) {
      AxisType type=timeAxis.getAxisType();
      String units=timeAxis.getUnitsString();
      String direction=DIRECTIONS.get(type);
      if (direction != null) {
        if (CF.POSITIVE_DOWN.equalsIgnoreCase(timeAxis.getPositive())) {
          direction=OPPOSITES.get(type);
        }
        final int offset=units.lastIndexOf('_');
        if (offset >= 0) {
          final String unitsDirection=units.substring(offset + 1).trim();
          final String opposite=OPPOSITES.get(type);
          if (unitsDirection.equalsIgnoreCase(opposite)) {
            direction=opposite;
          }
          if (unitsDirection.equalsIgnoreCase(direction)) {
            units=units.substring(0,offset).trim();
          }
        }
      }
      Date epoch=null;
      String t_originDate=null;
      if (AxisType.Time.equals(type)) {
        String origin=null;
        final String[] unitsParts=units.split("(?i)\\s+since\\s+");
        if (unitsParts.length == 2) {
          units=unitsParts[0].trim();
          origin=unitsParts[1].trim();
        }
 else {
          final Attribute attribute=timeAxis.findAttribute("time_origin");
          if (attribute != null) {
            origin=attribute.getStringValue();
          }
        }
        if (origin != null) {
          origin=UnidataTimeUtilities.trimFractionalPart(origin);
          origin=UnidataTimeUtilities.checkDateDigits(origin);
          try {
            epoch=(Date)UnidataUtilities.getAxisFormat(type,origin).parseObject(origin);
            GregorianCalendar cal=new GregorianCalendar();
            cal.setTime(epoch);
            DefaultInstant instant=new DefaultInstant(new DefaultPosition(cal.getTime()));
            t_originDate=instant.getPosition().getDateTime().toString();
          }
 catch (          ParseException e) {
            throw new IllegalArgumentException(e);
          }
        }
      }
      String axisName=timeAxis.getShortName();
      String t_csName="time_CS";
      final Map<String,String> csMap=Collections.singletonMap("name",t_csName);
      final TimeCS timeCS=UnidataCRSUtilities.FACTORY_CONTAINER.getCSFactory().createTimeCS(csMap,getAxis(axisName,getDirection(direction),units));
      if (t_datumName == null) {
        t_datumName="Unknown";
      }
      final Map<String,String> datumMap=Collections.singletonMap("name",t_datumName);
      final Position timeOrigin=new DefaultPosition(new SimpleInternationalString(t_originDate));
      final TemporalDatum temporalDatum=UnidataCRSUtilities.FACTORY_CONTAINER.getDatumFactory().createTemporalDatum(datumMap,timeOrigin.getDate());
      String crsName="time_CRS";
      final Map<String,String> crsMap=Collections.singletonMap("name",crsName);
      temporalCRS=UnidataCRSUtilities.FACTORY_CONTAINER.getCRSFactory().createTemporalCRS(crsMap,temporalDatum,timeCS);
    }
  }
 catch (  FactoryException e) {
    if (LOGGER.isLoggable(Level.FINE))     LOGGER.log(Level.FINE,"Unable to parse temporal CRS",e);
    temporalCRS=null;
  }
catch (  ParseException e) {
    if (LOGGER.isLoggable(Level.FINE))     LOGGER.log(Level.FINE,"Unable to parse temporal CRS",e);
    temporalCRS=null;
  }
  return temporalCRS;
}
