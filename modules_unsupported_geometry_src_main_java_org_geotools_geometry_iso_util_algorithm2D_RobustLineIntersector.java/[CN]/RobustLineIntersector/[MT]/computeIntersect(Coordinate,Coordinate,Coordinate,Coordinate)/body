{
  isProper=false;
  if (!Envelope.intersects(p1,p2,q1,q2))   return DONT_INTERSECT;
  int Pq1=CGAlgorithms.orientationIndex(p1,p2,q1);
  int Pq2=CGAlgorithms.orientationIndex(p1,p2,q2);
  if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {
    return DONT_INTERSECT;
  }
  int Qp1=CGAlgorithms.orientationIndex(q1,q2,p1);
  int Qp2=CGAlgorithms.orientationIndex(q1,q2,p2);
  if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {
    return DONT_INTERSECT;
  }
  boolean collinear=Pq1 == 0 && Pq2 == 0 && Qp1 == 0 && Qp2 == 0;
  if (collinear) {
    return computeCollinearIntersection(p1,p2,q1,q2);
  }
  if (Pq1 == 0 || Pq2 == 0 || Qp1 == 0 || Qp2 == 0) {
    isProper=false;
    if (Pq1 == 0) {
      intPt[0]=new Coordinate(q1);
    }
    if (Pq2 == 0) {
      intPt[0]=new Coordinate(q2);
    }
    if (Qp1 == 0) {
      intPt[0]=new Coordinate(p1);
    }
    if (Qp2 == 0) {
      intPt[0]=new Coordinate(p2);
    }
  }
 else {
    isProper=true;
    intPt[0]=intersection(p1,p2,q1,q2);
  }
  return DO_INTERSECT;
}
