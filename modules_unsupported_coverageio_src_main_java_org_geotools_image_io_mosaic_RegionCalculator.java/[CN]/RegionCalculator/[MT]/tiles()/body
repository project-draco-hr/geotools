{
  final Map<ImageGeometry,Tile[]> results=new HashMap<ImageGeometry,Tile[]>(4);
  for (  final Map<AffineTransform,Dimension> tilesAT : computePyramidLevels(tiles.keySet())) {
    AffineTransform reference=null;
    double xMin=Double.POSITIVE_INFINITY;
    double xLead=Double.POSITIVE_INFINITY;
    double yMin=Double.POSITIVE_INFINITY;
    double scale=Double.POSITIVE_INFINITY;
    for (    final AffineTransform tr : tilesAT.keySet()) {
      final double s=XAffineTransform.getScale(tr);
      double y=tr.getTranslateY();
      if (tr.getScaleY() < 0 || tr.getShearY() < 0)       y=-y;
      double x=tr.getTranslateX();
      if (tr.getScaleX() < 0 || tr.getShearX() < 0)       x=-x;
      if (!(Math.abs(s - scale) <= EPS)) {
        if (!(s < scale))         continue;
        scale=s;
        yMin=y;
        xMin=x;
      }
 else {
        if (x < xMin)         xMin=x;
        if (!(Math.abs(y - yMin) <= EPS)) {
          if (!(y < yMin))           continue;
          yMin=y;
        }
 else         if (!(x < xLead))         continue;
      }
      xLead=x;
      reference=tr;
    }
    if (reference == null) {
      continue;
    }
    xLead-=xMin;
    if (xLead > EPS) {
      final double[] matrix=new double[6];
      reference.getMatrix(matrix);
      matrix[4]-=xLead;
      reference=new AffineTransform(matrix);
    }
 else {
      reference=new AffineTransform(reference);
    }
    final AffineTransform toGrid;
    try {
      toGrid=reference.createInverse();
    }
 catch (    NoninvertibleTransformException e) {
      throw new IllegalStateException(e);
    }
    int index=0;
    Rectangle groupBounds=null;
    final Rectangle2D.Double envelope=new Rectangle2D.Double();
    final Tile[] tilesArray=new Tile[tilesAT.size()];
    for (    final Map.Entry<AffineTransform,Dimension> entry : tilesAT.entrySet()) {
      final AffineTransform tr=entry.getKey();
      Tile tile=tiles.remove(tr);
      tr.preConcatenate(toGrid);
      Rectangle bounds;
synchronized (tile) {
        tile.setSubsampling(entry.getValue());
        try {
          bounds=tile.getRegion();
        }
 catch (        IOException exception) {
          bounds=null;
          Logging.unexpectedException(RegionCalculator.class,"tiles",exception);
        }
        if (bounds != null) {
          XAffineTransform.transform(tr,bounds,envelope);
          bounds.x=(int)Math.round(envelope.x);
          bounds.y=(int)Math.round(envelope.y);
          bounds.width=(int)Math.round(envelope.width);
          bounds.height=(int)Math.round(envelope.height);
        }
 else {
          final Point location=tile.getLocation();
          tr.transform(location,location);
          bounds=new Rectangle(location.x,location.y,0,0);
        }
        tile.setAbsoluteRegion(bounds);
      }
      if (groupBounds == null) {
        groupBounds=bounds;
      }
 else {
        groupBounds.add(bounds);
      }
      tilesArray[index++]=tile;
    }
    tilesAT.clear();
    if (groupBounds != null) {
      final int dx=xLocation - groupBounds.x;
      final int dy=yLocation - groupBounds.y;
      if (dx != 0 || dy != 0) {
        reference.translate(-dx,-dy);
        groupBounds.translate(dx,dy);
      }
      final ImageGeometry geometry=new ImageGeometry(groupBounds,reference);
      reference=geometry.getGridToCRS();
      final Map<Dimension,TranslatedTransform> pool=new HashMap<Dimension,TranslatedTransform>();
      for (      final Tile tile : tilesArray) {
        final Dimension subsampling=tile.getSubsampling();
        TranslatedTransform translated=pool.get(subsampling);
        if (translated == null) {
          translated=new TranslatedTransform(subsampling,reference,dx,dy);
          pool.put(subsampling,translated);
        }
        translated.applyTo(tile);
      }
      results.put(geometry,tilesArray);
    }
  }
  return results;
}
