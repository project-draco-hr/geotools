{
  final RenderedImage sourceImage=sourceCoverage.getRenderedImage();
  final GridGeometry2D sourceGridGeometry=((GridGeometry2D)sourceCoverage.getGridGeometry());
  final GridEnvelope2D sourceGridRange=sourceGridGeometry.getGridRange2D();
  final boolean isSimpleTransform=CoverageUtilities.isSimpleGridToWorldTransform(sourceGridToWorldTransform,EPS);
  int actionTaken=0;
  final RenderingHints targetHints=new RenderingHints(null);
  if (hints != null)   targetHints.add(hints);
  final ImageLayout layout=initLayout(sourceImage,targetHints);
  targetHints.put(JAI.KEY_IMAGE_LAYOUT,layout);
  try {
    if (cropROI != null) {
      final Polygon modelSpaceROI=FeatureUtilities.getPolygon(cropEnvelope,GFACTORY);
      Geometry intersection=IntersectUtils.intersection(cropROI,modelSpaceROI);
      Envelope2D e2d=JTS.getEnvelope2D(intersection.getEnvelopeInternal(),cropEnvelope.getCoordinateReferenceSystem());
      GeneralEnvelope ge=new GeneralEnvelope((org.opengis.geometry.Envelope)e2d);
      cropEnvelope.setEnvelope(ge);
    }
    final AffineTransform sourceWorldToGridTransform=sourceGridToWorldTransform.createInverse();
    final Rectangle2D finalRasterAreaDouble=XAffineTransform.transform(sourceWorldToGridTransform,cropEnvelope.toRectangle2D(),null);
    final Rectangle finalRasterArea=finalRasterAreaDouble.getBounds();
    Rectangle.intersect(finalRasterArea,sourceGridRange,finalRasterArea);
    if (finalRasterArea.isEmpty())     throw new CannotCropException(Errors.format(ErrorKeys.CANT_CROP));
    if (finalRasterArea.equals(sourceGridRange) && isSimpleTransform && cropROI == null)     return sourceCoverage;
    final double minX=finalRasterArea.getMinX();
    final double minY=finalRasterArea.getMinY();
    final double width=finalRasterArea.getWidth();
    final double height=finalRasterArea.getHeight();
    final PlanarImage croppedImage;
    ImageWorker worker=new ImageWorker();
    java.awt.Polygon rasterSpaceROI=null;
    double[] background=destnodata != null ? destnodata : CoverageUtilities.getBackgroundValues(sourceCoverage);
    String operatioName=null;
    if (!isSimpleTransform || cropROI != null || nodata != null) {
      Polygon modelSpaceROI=FeatureUtilities.getPolygon(cropEnvelope,GFACTORY);
      final List<Point2D> points=new ArrayList<Point2D>(5);
      rasterSpaceROI=FeatureUtilities.convertPolygonToPointArray(modelSpaceROI,ProjectiveTransform.create(sourceWorldToGridTransform),points);
      if (isSimpleTransform && cropROI == null) {
        rasterSpaceROI=rectangleToPolygon(finalRasterArea);
      }
      if (rasterSpaceROI == null || rasterSpaceROI.getBounds().isEmpty())       if (finalRasterArea.isEmpty())       throw new CannotCropException(Errors.format(ErrorKeys.CANT_CROP));
      final boolean doMosaic=forceMosaic ? true : decideJAIOperation(roiTolerance,rasterSpaceROI.getBounds2D(),points);
      if (doMosaic || cropROI != null || internalROI != null || nodata != null) {
        final ROI[] roiarr;
        try {
          if (cropROI != null) {
            final LiteShape2 cropRoiLS2=new LiteShape2(cropROI,ProjectiveTransform.create(sourceWorldToGridTransform),null,false);
            ROI cropRS=new ROIShape(cropRoiLS2);
            Rectangle2D rt=cropRoiLS2.getBounds2D();
            if (!hasIntegerBounds(rt)) {
              Geometry geo=(Geometry)cropRoiLS2.getGeometry().clone();
              transformGeometry(geo);
              cropRS=new ROIShape(new LiteShape2(geo,null,null,false));
            }
            roiarr=new ROI[]{cropRS};
          }
 else {
            ROI roi=new ROIShape(rasterSpaceROI);
            roiarr=new ROI[]{roi};
          }
          if (roiarr[0].getBounds().isEmpty()) {
            throw new CannotCropException(Errors.format(ErrorKeys.CANT_CROP));
          }
        }
 catch (        FactoryException ex) {
          throw new CannotCropException(Errors.format(ErrorKeys.CANT_CROP),ex);
        }
        worker.setBackground(background);
        final Rectangle bounds=rasterSpaceROI.getBounds2D().getBounds();
        Rectangle.intersect(bounds,sourceGridRange,bounds);
        if (bounds.isEmpty())         throw new CannotCropException(Errors.format(ErrorKeys.CANT_CROP));
        if (!doMosaic && bounds.getBounds().equals(sourceGridRange) && isSimpleTransform&& nodata == null)         return sourceCoverage;
        final Rectangle boundsInt=bounds.getBounds();
        layout.setMinX(boundsInt.x);
        layout.setWidth(boundsInt.width);
        layout.setMinY(boundsInt.y);
        layout.setHeight(boundsInt.height);
        operatioName="Mosaic";
        worker.setRenderingHints(targetHints);
        worker.mosaic(new RenderedImage[]{sourceImage},MosaicDescriptor.MOSAIC_TYPE_OVERLAY,null,roiarr,null,nodata != null ? new Range[]{nodata} : null);
      }
    }
    if (operatioName == null) {
      worker.setImage(sourceImage);
      worker.setNoData(null);
      worker.setRenderingHints(targetHints);
      worker.crop((float)minX,(float)minY,(float)width,(float)height);
      operatioName="Crop";
    }
    croppedImage=worker.getPlanarImage();
    Map sourceProperties=sourceCoverage.getProperties();
    Map properties=null;
    if (sourceProperties != null && !sourceProperties.isEmpty()) {
      properties=new HashMap(sourceProperties);
    }
    if (rasterSpaceROI != null || internalROI != null) {
      ROI finalROI=null;
      if (rasterSpaceROI != null) {
        finalROI=new ROIShape(rasterSpaceROI);
      }
      if (finalROI != null && internalROI != null) {
        finalROI=finalROI.intersect(internalROI);
      }
 else       if (internalROI != null) {
        finalROI=internalROI;
      }
      if (properties == null) {
        properties=new HashMap();
      }
      if (finalROI != null) {
        CoverageUtilities.setROIProperty(properties,finalROI);
      }
    }
    if (worker.getNoData() != null) {
      if (properties == null) {
        properties=new HashMap();
      }
      CoverageUtilities.setNoDataProperty(properties,worker.getNoData());
    }
    return new GridCoverageFactory(hints).create(sourceCoverage.getName(),croppedImage,new GridGeometry2D(new GridEnvelope2D(croppedImage.getBounds()),sourceGridGeometry.getGridToCRS2D(PixelOrientation.CENTER),sourceCoverage.getCoordinateReferenceSystem()),(GridSampleDimension[])(actionTaken == 1 ? null : sourceCoverage.getSampleDimensions().clone()),new GridCoverage[]{sourceCoverage},properties);
  }
 catch (  TransformException e) {
    throw new CannotCropException(Errors.format(ErrorKeys.CANT_CROP),e);
  }
catch (  NoninvertibleTransformException e) {
    throw new CannotCropException(Errors.format(ErrorKeys.CANT_CROP),e);
  }
}
