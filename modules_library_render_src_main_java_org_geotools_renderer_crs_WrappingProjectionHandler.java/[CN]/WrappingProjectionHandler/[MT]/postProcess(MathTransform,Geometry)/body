{
  Envelope env=geometry.getEnvelopeInternal();
  final double width;
  final double reWidth;
  final boolean northEast=CRS.getAxisOrder(targetCRS) == CRS.AxisOrder.NORTH_EAST;
  if (northEast) {
    width=env.getHeight();
    reWidth=renderingEnvelope.getHeight();
  }
 else {
    width=env.getWidth();
    reWidth=renderingEnvelope.getWidth();
  }
  if (width < radius && renderingEnvelope.contains(env) && reWidth <= radius * 2) {
    return geometry;
  }
  if (datelineWrappingCheckEnabled && width > radius && width < radius * 2) {
    Geometry wrapped=(Geometry)geometry.clone();
    wrapped.apply(new WrappingCoordinateFilter(radius,radius * 2,mt,northEast));
    wrapped.geometryChanged();
    if (wrapped.getEnvelopeInternal().getWidth() < radius) {
      geometry=wrapped;
      env=geometry.getEnvelopeInternal();
    }
  }
  List<Geometry> geoms=new ArrayList<Geometry>();
  Class geomType=null;
  double base, curr, lowLimit, highLimit;
  if (northEast) {
    base=env.getMinY();
    curr=env.getMinY();
    lowLimit=Math.max(renderingEnvelope.getMinY(),renderingEnvelope.getMedian(1) - maxWraps * radius * 2);
    highLimit=Math.min(renderingEnvelope.getMaxY(),renderingEnvelope.getMedian(1) + maxWraps * radius * 2);
  }
 else {
    base=env.getMinX();
    curr=env.getMinX();
    lowLimit=Math.max(renderingEnvelope.getMinX(),renderingEnvelope.getMedian(0) - maxWraps * radius * 2);
    highLimit=Math.min(renderingEnvelope.getMaxX(),renderingEnvelope.getMedian(0) + maxWraps * radius * 2);
  }
  while (curr > lowLimit) {
    curr-=radius * 2;
  }
  geomType=accumulate(geoms,geometry,geomType);
  while (curr <= highLimit) {
    double offset=curr - base;
    if (Math.abs(offset) < radius) {
    }
 else {
      Geometry offseted=(Geometry)geometry.clone();
      offseted.apply(new OffsetOrdinateFilter(northEast ? 1 : 0,offset));
      offseted.geometryChanged();
      geomType=accumulate(geoms,offseted,geomType);
    }
    curr+=radius * 2;
  }
  if (geomType == null) {
    return null;
  }
  if (geoms.size() == 1) {
    return geoms.get(0);
  }
  if (Point.class.equals(geomType)) {
    Point[] points=geoms.toArray(new Point[geoms.size()]);
    return geometry.getFactory().createMultiPoint(points);
  }
 else   if (LineString.class.isAssignableFrom(geomType)) {
    LineString[] lines=geoms.toArray(new LineString[geoms.size()]);
    return geometry.getFactory().createMultiLineString(lines);
  }
 else   if (Polygon.class.equals(geomType)) {
    Polygon[] polys=geoms.toArray(new Polygon[geoms.size()]);
    return geometry.getFactory().createMultiPolygon(polys);
  }
 else {
    return geometry.getFactory().createGeometryCollection(geoms.toArray(new Geometry[geoms.size()]));
  }
}
