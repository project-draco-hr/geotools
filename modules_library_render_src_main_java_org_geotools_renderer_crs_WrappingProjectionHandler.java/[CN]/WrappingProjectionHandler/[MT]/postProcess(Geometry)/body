{
  Envelope env=geometry.getEnvelopeInternal();
  if (env.getWidth() < radius && renderingEnvelope.contains(env) && renderingEnvelope.getWidth() <= radius * 2)   return geometry;
  if (env.getWidth() > radius && env.getWidth() < radius * 2) {
    geometry.apply(new WrappingCoordinateFilter(radius,radius * 2));
    geometry.geometryChanged();
    env=geometry.getEnvelopeInternal();
  }
  List<Geometry> geoms=new ArrayList<Geometry>();
  Class geomType=null;
  double min=env.getMinX();
  double max=env.getMaxX();
  while (min > renderingEnvelope.getMinX()) {
    min-=radius * 2;
    max-=radius * 2;
  }
  while (max < renderingEnvelope.getMinX()) {
    min+=radius * 2;
    max+=radius * 2;
  }
  while (min <= renderingEnvelope.getMaxX()) {
    double offset=min - env.getMinX();
    if (Math.abs(offset) < radius) {
      geomType=accumulate(geoms,geometry,geomType);
    }
 else {
      Geometry offseted=(Geometry)geometry.clone();
      offseted.apply(new OffsetOrdinateFilter(0,offset));
      offseted.geometryChanged();
      geomType=accumulate(geoms,offseted,geomType);
    }
    min+=radius * 2;
  }
  if (geomType == null) {
    return null;
  }
  if (geoms.size() == 1) {
    return geometry;
  }
  if (Point.class.equals(geomType)) {
    Point[] points=(Point[])geoms.toArray(new Point[geoms.size()]);
    return geometry.getFactory().createMultiPoint(points);
  }
 else   if (LineString.class.isAssignableFrom(geomType)) {
    LineString[] lines=(LineString[])geoms.toArray(new LineString[geoms.size()]);
    return geometry.getFactory().createMultiLineString(lines);
  }
 else   if (Polygon.class.equals(geomType)) {
    Polygon[] polys=(Polygon[])geoms.toArray(new Polygon[geoms.size()]);
    return geometry.getFactory().createMultiPolygon(polys);
  }
 else {
    return geometry.getFactory().createGeometryCollection((Geometry[])geoms.toArray(new Geometry[geoms.size()]));
  }
}
