{
  super(vectorize(sources),layoutHelper(sources,layout),config,true);
  permitInPlaceOperation();
  int numSrcs=sources.size();
  colorModels=new ColorModel[numSrcs];
  for (int i=0; i < numSrcs; i++) {
    colorModels[i]=((RenderedImage)sources.get(i)).getColorModel();
  }
  int dataType=getSampleModel().getDataType();
switch (dataType) {
case DataBuffer.TYPE_BYTE:
    this.destNoDataByte=ImageUtil.clampRoundByte(destinationNoData);
  break;
case DataBuffer.TYPE_USHORT:
this.destNoDataShort=ImageUtil.clampRoundUShort(destinationNoData);
break;
case DataBuffer.TYPE_SHORT:
this.destNoDataShort=ImageUtil.clampRoundShort(destinationNoData);
break;
case DataBuffer.TYPE_INT:
this.destNoDataInt=ImageUtil.clampRoundInt(destinationNoData);
break;
case DataBuffer.TYPE_FLOAT:
this.destNoDataFloat=ImageUtil.clampFloat(destinationNoData);
break;
case DataBuffer.TYPE_DOUBLE:
this.destNoDataDouble=destinationNoData;
break;
default :
throw new IllegalArgumentException("Wrong image data type");
}
if (noData != null) {
if (noData.length != numSrcs) {
Range firstNoData=noData[0];
this.noData=new Range[numSrcs];
for (int i=0; i < numSrcs; i++) {
this.noData[i]=firstNoData;
}
}
 else {
this.noData=noData;
}
this.hasNoData=true;
}
 else {
this.noData=null;
this.hasNoData=false;
}
this.roi=roi;
hasROI=roi != null;
caseA=!hasROI && !hasNoData;
caseB=hasROI && !hasNoData;
caseC=!hasROI && hasNoData;
}
