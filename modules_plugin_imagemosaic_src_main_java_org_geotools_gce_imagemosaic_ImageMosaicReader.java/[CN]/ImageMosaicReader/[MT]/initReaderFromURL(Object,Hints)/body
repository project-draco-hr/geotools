{
  this.sourceURL=Utils.checkSource(source,hints);
  if (this.sourceURL == null)   throw new DataSourceException("This plugin accepts File, URL or String. The string may describe a File or an URL");
  MosaicConfigurationBean configuration=Utils.loadMosaicProperties(sourceURL,this.locationAttributeName);
  if (configuration == null) {
    final File parent=DataUtilities.urlToFile(sourceURL).getParentFile();
    final File[] properties=parent.listFiles((FilenameFilter)FileFilterUtils.and(FileFilterUtils.notFileFilter(FileFilterUtils.nameFileFilter("indexer.properties")),FileFilterUtils.and(FileFilterUtils.notFileFilter(FileFilterUtils.nameFileFilter("datastore.properties")),FileFilterUtils.makeFileOnly(FileFilterUtils.suffixFileFilter(".properties")))));
    for (    File propFile : properties)     if (Utils.checkFileReadable(propFile) && Utils.loadMosaicProperties(DataUtilities.fileToURL(propFile),"") != null) {
      configuration=Utils.loadMosaicProperties(DataUtilities.fileToURL(propFile),this.locationAttributeName);
    }
  }
  if (configuration == null)   throw new DataSourceException("Unable to create reader for this mosaic since we could not parse the configuration.");
  extractProperties(configuration);
  if (this.hints.containsKey(Hints.MOSAIC_LOCATION_ATTRIBUTE))   this.locationAttributeName=((String)this.hints.get(Hints.MOSAIC_LOCATION_ATTRIBUTE));
  try {
    catalog=GranuleCatalogFactory.createGranuleCatalog(sourceURL,configuration);
    if (catalog == null)     throw new DataSourceException("Unable to create index for this URL " + sourceURL);
    if (LOGGER.isLoggable(Level.FINE))     LOGGER.fine("Connected mosaic reader to its index " + sourceURL.toString());
    final SimpleFeatureType type=catalog.getType();
    if (type == null)     throw new IllegalArgumentException("Problems when opening the index, no typenames for the schema are defined");
    setGridGeometry(configuration.getEnvelope());
    final Object tempCRS=this.hints.get(Hints.DEFAULT_COORDINATE_REFERENCE_SYSTEM);
    if (tempCRS != null) {
      this.crs=(CoordinateReferenceSystem)tempCRS;
      LOGGER.log(Level.WARNING,"Using forced coordinate reference system ");
    }
 else {
      final CoordinateReferenceSystem tempcrs=type.getGeometryDescriptor().getCoordinateReferenceSystem();
      if (tempcrs == null) {
        crs=AbstractGridFormat.getDefaultCRS();
        LOGGER.log(Level.WARNING,"Unable to find a CRS for this coverage, using a default one");
      }
 else       crs=tempcrs;
    }
    if (this.locationAttributeName == null) {
      throw new DataSourceException("The provided name for the location attribute is invalid.");
    }
 else {
      if (type.getDescriptor(this.locationAttributeName) == null) {
        this.locationAttributeName=this.locationAttributeName.toUpperCase();
        if (type.getDescriptor(this.locationAttributeName) == null) {
          throw new DataSourceException("The provided name for the location attribute is invalid.");
        }
      }
    }
    if (this.timeAttribute != null && this.timeAttribute.length() > 0 && type.getDescriptor(this.timeAttribute) == null)     throw new DataSourceException("The provided name for the timeAttribute attribute is invalid.");
    rasterManager=new RasterManager(this);
  }
 catch (  Throwable e) {
    try {
      if (catalog != null)       catalog.dispose();
    }
 catch (    Throwable e1) {
      if (LOGGER.isLoggable(Level.FINEST))       LOGGER.log(Level.FINEST,e1.getLocalizedMessage(),e1);
    }
 finally {
      catalog=null;
    }
    try {
      if (rasterManager != null)       rasterManager.dispose();
    }
 catch (    Throwable e1) {
      if (LOGGER.isLoggable(Level.FINEST))       LOGGER.log(Level.FINEST,e1.getLocalizedMessage(),e1);
    }
 finally {
      rasterManager=null;
    }
    throw new DataSourceException(e);
  }
}
