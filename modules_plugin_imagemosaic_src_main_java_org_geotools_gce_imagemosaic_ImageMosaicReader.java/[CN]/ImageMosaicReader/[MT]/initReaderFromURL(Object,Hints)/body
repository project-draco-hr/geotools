{
  this.sourceURL=Utils.checkSource(source,hints);
  if (this.sourceURL == null)   throw new DataSourceException("This plugin accepts File, URL or String. The string may describe a File or an URL");
  final MosaicConfigurationBean configuration=loadMosaicProperties();
  if (configuration == null)   throw new DataSourceException("Unable to create reader for this mosaic since we could not parse the configuration.");
  if (this.hints.containsKey(Hints.MOSAIC_LOCATION_ATTRIBUTE))   this.locationAttributeName=((String)this.hints.get(Hints.MOSAIC_LOCATION_ATTRIBUTE));
  try {
    catalog=GranuleCatalogFactory.createGranuleCatalog(sourceURL,configuration);
    if (catalog == null)     throw new DataSourceException("Unable to create index for this URL " + sourceURL);
    if (LOGGER.isLoggable(Level.FINE))     LOGGER.fine("Connected mosaic reader to its index " + sourceURL.toString());
    final SimpleFeatureType type=catalog.getType();
    if (type == null)     throw new IllegalArgumentException("Problems when opening the index, no typenames for the schema are defined");
    setGridGeometry(configuration.getEnvelope());
    final Object tempCRS=this.hints.get(Hints.DEFAULT_COORDINATE_REFERENCE_SYSTEM);
    if (tempCRS != null) {
      this.crs=(CoordinateReferenceSystem)tempCRS;
      LOGGER.log(Level.WARNING,"Using forced coordinate reference system ");
    }
 else {
      final CoordinateReferenceSystem tempcrs=type.getGeometryDescriptor().getCoordinateReferenceSystem();
      if (tempcrs == null) {
        crs=AbstractGridFormat.getDefaultCRS();
        LOGGER.log(Level.WARNING,"Unable to find a CRS for this coverage, using a default one");
      }
 else       crs=tempcrs;
    }
    if (this.locationAttributeName == null) {
      for (      AttributeDescriptor attribute : type.getAttributeDescriptors()) {
        if (attribute.getType().getBinding().equals(String.class))         this.locationAttributeName=attribute.getName().toString();
      }
    }
    if (type.getDescriptor(this.locationAttributeName) == null)     throw new DataSourceException("The provided name for the location attribute is invalid.");
    if (this.timeAttribute == null) {
      for (      AttributeDescriptor attribute : type.getAttributeDescriptors()) {
        if (attribute.getType().getBinding().equals(Date.class)) {
          this.timeAttribute=attribute.getName().toString();
          break;
        }
        if (attribute.getType().getBinding().equals(Timestamp.class)) {
          this.timeAttribute=attribute.getName().toString();
          break;
        }
        if (attribute.getType().getBinding().equals(java.sql.Date.class)) {
          this.timeAttribute=attribute.getName().toString();
          break;
        }
      }
    }
    if (this.timeAttribute != null && this.timeAttribute.length() > 0 && type.getDescriptor(this.timeAttribute) == null)     throw new DataSourceException("The provided name for the timeAttribute attribute is invalid.");
    rasterManager=new RasterManager(this);
  }
 catch (  Throwable e) {
    try {
      if (catalog != null)       catalog.dispose();
    }
 catch (    Throwable e1) {
      if (LOGGER.isLoggable(Level.FINEST))       LOGGER.log(Level.FINEST,e1.getLocalizedMessage(),e1);
    }
 finally {
      catalog=null;
    }
    try {
      if (rasterManager != null)       rasterManager.dispose();
    }
 catch (    Throwable e1) {
      if (LOGGER.isLoggable(Level.FINEST))       LOGGER.log(Level.FINEST,e1.getLocalizedMessage(),e1);
    }
 finally {
      rasterManager=null;
    }
    throw new DataSourceException(e);
  }
}
