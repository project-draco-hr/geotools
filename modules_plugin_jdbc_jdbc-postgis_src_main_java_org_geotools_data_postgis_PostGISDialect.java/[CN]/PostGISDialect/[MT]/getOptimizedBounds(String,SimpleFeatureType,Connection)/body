{
  if (!estimatedExtentsEnabled)   return null;
  String tableName=featureType.getTypeName();
  Statement st=null;
  ResultSet rs=null;
  List<ReferencedEnvelope> result=new ArrayList<ReferencedEnvelope>();
  Savepoint savePoint=null;
  try {
    st=cx.createStatement();
    if (!cx.getAutoCommit()) {
      savePoint=cx.setSavepoint();
    }
    for (    AttributeDescriptor att : featureType.getAttributeDescriptors()) {
      if (att instanceof GeometryDescriptor) {
        StringBuffer sql=new StringBuffer();
        sql.append("select ST_AsText(ST_force_2d(ST_Envelope(ST_Estimated_Extent('");
        if (schema != null) {
          sql.append(schema);
          sql.append("', '");
        }
        sql.append(tableName);
        sql.append("', '");
        sql.append(att.getName().getLocalPart());
        sql.append("'))))");
        rs=st.executeQuery(sql.toString());
        if (rs.next()) {
          Envelope env=decodeGeometryEnvelope(rs,1,cx);
          if (!env.isNull()) {
            CoordinateReferenceSystem crs=((GeometryDescriptor)att).getCoordinateReferenceSystem();
            result.add(new ReferencedEnvelope(env,crs));
          }
        }
        rs.close();
      }
    }
  }
 catch (  SQLException e) {
    if (savePoint != null) {
      cx.rollback(savePoint);
    }
    LOGGER.log(Level.WARNING,"Failed to use ST_Estimated_Extent, falling back on envelope aggregation",e);
    return null;
  }
 finally {
    if (savePoint != null) {
      cx.releaseSavepoint(savePoint);
    }
    dataStore.closeSafe(rs);
    dataStore.closeSafe(st);
  }
  return result;
}
