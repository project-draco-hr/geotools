{
  Coordinate center;
  double centerX, centerY, radius;
  double temp, bc, cd, determinate;
  if (abs(p1.x - p3.x) < EPSILON_SQLMM && abs(p1.y - p3.y) < EPSILON_SQLMM) {
    centerX=p1.x + (p2.x - p1.x) / 2.0;
    centerY=p1.y + (p2.y - p1.y) / 2.0;
    center=new Coordinate();
    center.x=centerX;
    center.y=centerY;
    radius=sqrt((centerX - p1.x) * (centerX - p1.x) + (centerY - p1.y) * (centerY - p1.y));
  }
 else {
    temp=p2.x * p2.x + p2.y * p2.y;
    bc=(p1.x * p1.x + p1.y * p1.y - temp) / 2.0;
    cd=(temp - p3.x * p3.x - p3.y * p3.y) / 2.0;
    determinate=(p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p2.y);
    if (abs(determinate) < EPSILON_SQLMM) {
      List<Coordinate> curve=new ArrayList<Coordinate>();
      curve.add(p1);
      curve.add(p3);
      return curve;
    }
    determinate=1.0 / determinate;
    centerX=(bc * (p2.y - p3.y) - cd * (p1.y - p2.y)) * determinate;
    centerY=((p1.x - p2.x) * cd - (p2.x - p3.x) * bc) * determinate;
    center=new Coordinate();
    center.x=centerX;
    center.y=centerY;
    radius=sqrt((centerX - p1.x) * (centerX - p1.x) + (centerY - p1.y) * (centerY - p1.y));
  }
  return circularSegmentize(p1,p2,p3,center,radius,32);
}
