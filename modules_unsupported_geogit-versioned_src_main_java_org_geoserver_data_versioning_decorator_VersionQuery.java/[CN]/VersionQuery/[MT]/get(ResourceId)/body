{
  final String featureId=id.getID();
  final String featureVersion=id.getFeatureVersion();
  final Version version=id.getVersion();
  final boolean isDateRangeQuery=id.getStartTime() != null || id.getEndTime() != null;
  final boolean isVesionQuery=!version.isEmpty();
  final Ref requestedVersionRef=extractRequestedVersion(ggit,featureId,featureVersion);
{
    final boolean explicitVersionQuery=!isDateRangeQuery && !isVesionQuery;
    if (explicitVersionQuery) {
      if (requestedVersionRef == null) {
        return Iterators.emptyIterator();
      }
 else {
        return Iterators.singletonIterator(requestedVersionRef);
      }
    }
  }
  List<Ref> result=new ArrayList<Ref>(5);
  final List<String> path=path(featureId);
  LogOp logOp=ggit.log().addPath(path);
  if (isDateRangeQuery) {
    Date startTime=id.getStartTime() == null ? new Date(0L) : id.getStartTime();
    Date endTime=id.getEndTime() == null ? new Date(Long.MAX_VALUE) : id.getEndTime();
    boolean isMinIncluded=true;
    boolean isMaxIncluded=true;
    Range<Date> timeRange=new Range<Date>(Date.class,startTime,isMinIncluded,endTime,isMaxIncluded);
    logOp.setTimeRange(timeRange);
  }
  Iterator<RevCommit> featureCommits=logOp.call();
  if (isDateRangeQuery) {
    List<Ref> allInAscendingOrder=getAllInAscendingOrder(ggit,featureCommits,featureId);
    result.addAll(allInAscendingOrder);
  }
 else   if (isVesionQuery) {
    if (version.isDateTime()) {
      final Date validAsOf=version.getDateTime();
      RevCommit closest=findClosest(validAsOf,featureCommits);
      if (closest != null) {
        featureCommits=Iterators.singletonIterator(closest);
        result.addAll(getAllInAscendingOrder(ggit,featureCommits,featureId));
      }
    }
 else     if (version.isIndex()) {
      final int requestIndex=version.getIndex().intValue();
      final int listIndex=requestIndex - 1;
      List<Ref> allVersions=getAllInAscendingOrder(ggit,featureCommits,featureId);
      if (allVersions.size() > 0) {
        if (allVersions.size() >= requestIndex) {
          result.add(allVersions.get(listIndex));
        }
 else {
          result.add(allVersions.get(allVersions.size() - 1));
        }
      }
    }
 else     if (version.isVersionAction()) {
      final Action versionAction=version.getVersionAction();
      List<Ref> allInAscendingOrder=getAllInAscendingOrder(ggit,featureCommits,featureId);
switch (versionAction) {
case ALL:
        result.addAll(allInAscendingOrder);
      break;
case FIRST:
    if (allInAscendingOrder.size() > 0) {
      result.add(allInAscendingOrder.get(0));
    }
  break;
case LAST:
if (allInAscendingOrder.size() > 0) {
  result.add(allInAscendingOrder.get(allInAscendingOrder.size() - 1));
}
break;
case NEXT:
Ref next=next(requestedVersionRef,allInAscendingOrder);
if (next != null) {
result.add(next);
}
break;
case PREVIOUS:
Ref previous=previous(requestedVersionRef,allInAscendingOrder);
if (previous != null) {
result.add(previous);
}
break;
default :
break;
}
}
}
return result.iterator();
}
