{
  if (baseFilter == null) {
    return baseFilter;
  }
  if (targetFilter == null) {
    return baseFilter;
  }
  if (baseFilter.equals(targetFilter)) {
    return Filter.INCLUDE;
  }
  if (!(baseFilter instanceof BinaryLogicOperator)) {
    return baseFilter;
  }
  if (recurse) {
    DuplicatingFilterVisitor remove=new DuplicatingFilterVisitor(){
      public Object visit(      Or filter,      Object extraData){
        List<Filter> newChildren=children(filter,targetFilter,extraData);
        if (newChildren.isEmpty()) {
          return Filter.EXCLUDE;
        }
 else         if (newChildren.size() == 1) {
          return newChildren.get(0);
        }
 else {
          return getFactory(extraData).or(newChildren);
        }
      }
      public Object visit(      And filter,      Object extraData){
        List<Filter> newChildren=children(filter,targetFilter,extraData);
        if (newChildren.isEmpty()) {
          return Filter.INCLUDE;
        }
 else         if (newChildren.size() == 1) {
          return newChildren.get(0);
        }
 else {
          return getFactory(extraData).and(newChildren);
        }
      }
      private List<Filter> children(      BinaryLogicOperator filter,      final Filter targetFilter,      Object extraData){
        List<Filter> children=filter.getChildren();
        List<Filter> newChildren=new ArrayList<Filter>();
        for (Iterator<Filter> iter=children.iterator(); iter.hasNext(); ) {
          Filter child=iter.next();
          if (targetFilter.equals(child)) {
            continue;
          }
          if (child != null) {
            Filter newChild=(Filter)child.accept(this,extraData);
            newChildren.add(newChild);
          }
        }
        return newChildren;
      }
    }
;
    return (Filter)baseFilter.accept(remove,ff);
  }
 else {
    BinaryLogicOperator blo=(BinaryLogicOperator)baseFilter;
    List<Filter> children=blo.getChildren();
    if (children == null) {
      children=Collections.emptyList();
    }
    List<Filter> copy=new ArrayList<Filter>(children.size());
    for (    Filter filter : children) {
      if (targetFilter.equals(filter)) {
        continue;
      }
      copy.add(filter);
    }
    if (copy.isEmpty()) {
      if (baseFilter instanceof And) {
        return Filter.INCLUDE;
      }
 else       if (baseFilter instanceof Or) {
        return Filter.EXCLUDE;
      }
 else {
        return Filter.EXCLUDE;
      }
    }
 else     if (copy.size() == 1) {
      return copy.get(0);
    }
 else     if (baseFilter instanceof And) {
      return ff.and(children);
    }
 else     if (baseFilter instanceof Or) {
      return ff.or(children);
    }
 else {
      return Filter.INCLUDE;
    }
  }
}
