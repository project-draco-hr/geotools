{
  final DataType dataType, scaleType, rangeType;
  imageType=getRawDataType(variable);
  dataType=widestType=variable.getDataType();
  scale=attribute(variable,"scale_factor");
  offset=attribute(variable,"add_offset");
  scaleType=widestType;
  widestType=dataType;
  double minimum=Double.NaN;
  double maximum=Double.NaN;
  Attribute attribute=variable.findAttribute("valid_range");
  if (attribute != null) {
    widestType=widest(attribute.getDataType(),widestType);
    Number value=attribute.getNumericValue(0);
    if (value != null) {
      minimum=value.doubleValue();
    }
    value=attribute.getNumericValue(1);
    if (value != null) {
      maximum=value.doubleValue();
    }
  }
  if (Double.isNaN(minimum)) {
    minimum=attribute(variable,"valid_min");
  }
  if (Double.isNaN(maximum)) {
    maximum=attribute(variable,"valid_max");
  }
  rangeType=widestType;
  widestType=dataType;
  if (!forceRangePacking) {
    forceRangePacking=rangeType.equals(scaleType) && rangeType.equals(widest(rangeType,dataType));
  }
  if (forceRangePacking) {
    final double offset=Double.isNaN(this.offset) ? 0 : this.offset;
    final double scale=Double.isNaN(this.scale) ? 1 : this.scale;
    minimum=(minimum - offset) / scale;
    maximum=(maximum - offset) / scale;
    if (!isFloatingPoint(rangeType)) {
      if (!Double.isNaN(minimum) && !Double.isInfinite(minimum)) {
        minimum=Math.round(minimum);
      }
      if (!Double.isNaN(maximum) && !Double.isInfinite(maximum)) {
        maximum=Math.round(maximum);
      }
    }
  }
  if (Double.isNaN(minimum))   minimum=Double.NEGATIVE_INFINITY;
  if (Double.isNaN(maximum))   maximum=Double.POSITIVE_INFINITY;
  this.minimum=minimum;
  this.maximum=maximum;
  widestType=dataType;
  attribute=variable.findAttribute("missing_value");
  final double fillValue=attribute(variable,"_FillValue");
  final int fillCount=Double.isNaN(fillValue) ? 0 : 1;
  final int missingCount=(attribute != null) ? attribute.getLength() : 0;
  final double[] missings=new double[fillCount + missingCount];
  if (fillCount != 0) {
    missings[0]=fillValue;
  }
  int count=fillCount;
  scan:   for (int i=0; i < missingCount; i++) {
    final Number number=attribute.getNumericValue(i);
    if (number != null) {
      final double value=number.doubleValue();
      if (!Double.isNaN(value)) {
        for (int j=0; j < count; j++) {
          if (value == missings[j]) {
            continue scan;
          }
        }
        missings[count++]=value;
      }
    }
  }
  missingValues=(count != 0) ? XArray.resize(missings,count) : null;
}
