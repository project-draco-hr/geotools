{
  final List<CoverageProcessingNode> localSources=getSources();
  final int length=localSources.size();
  if (length == 0)   throw new IllegalArgumentException(Errors.format(ErrorKeys.SOURCE_CANT_BE_NULL_$1,"ChannelSelectionNode"));
  final GridCoverage2D source=(GridCoverage2D)getSource(0).getOutput();
  GridCoverageRendererUtilities.ensureSourceNotNull(source,this.getName().toString());
  final RootNode chainSource=new RootNode(source,getHints());
  final BandMergeNode subChainSink=new BandMergeNode(getHints());
  setSink(subChainSink);
  if (cs != null) {
    final SelectedChannelType[] rgb=cs.getRGBChannels();
    final SelectedChannelType gray=cs.getGrayChannel();
    if ((rgb != null && rgb[0] != null && rgb[1] != null && rgb[2] != null) && (gray != null))     throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1,"Both gray and rgb channel selection are valid!"));
    final SelectedChannelType[] sc=gray == null ? rgb : new SelectedChannelType[]{gray};
    if (sc != null && ((sc.length == 1 && sc[0] != null) || (sc.length == 3 && sc[0] != null && sc[1] != null && sc[2] != null))) {
      if (sc.length != 3 && sc.length != 1)       throw new IllegalArgumentException(Errors.format(ErrorKeys.BAD_BAND_NUMBER_$1,Integer.valueOf(sc.length)));
      for (int i=0; i < sc.length; i++) {
        final SelectedChannelType channel=sc[i];
        if (LOGGER.isLoggable(Level.FINE))         LOGGER.fine("Channel " + i + " was "+ channel.getChannelName());
        final BandSelectionNode bandSelectionNode=new BandSelectionNode();
        bandSelectionNode.addSource(chainSource);
        bandSelectionNode.visit(channel);
        final ContrastEnhancementNode contrastenhancementNode=new ContrastEnhancementNode();
        contrastenhancementNode.addSource(bandSelectionNode);
        bandSelectionNode.addSink(contrastenhancementNode);
        contrastenhancementNode.visit(channel != null ? channel.getContrastEnhancement() : null);
        contrastenhancementNode.addSink(subChainSink);
        subChainSink.addSource(contrastenhancementNode);
      }
      return;
    }
  }
  subChainSink.addSource(chainSource);
}
