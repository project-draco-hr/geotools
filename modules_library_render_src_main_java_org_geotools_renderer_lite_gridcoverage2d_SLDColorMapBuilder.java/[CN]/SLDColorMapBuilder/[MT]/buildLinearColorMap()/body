{
  if (this.numberColorMapEntries == -1)   throw new IllegalStateException(Errors.format(ErrorKeys.ILLEGAL_STATE));
  if (this.colorMap != null)   return this.colorMap;
  LinearColorMapElement last=(LinearColorMapElement)this.colormapElements.get(this.colormapElements.size() - 1);
  if (linearColorMapType == ColorMap.TYPE_RAMP) {
    final LinearColorMapElement previous=last;
    last=LinearColorMapElement.create("ColorMapEntry" + this.colormapElements.size(),lastColorValue,RangeFactory.create(previous.getRange().getMax().doubleValue(),true,Double.POSITIVE_INFINITY,false),previous.getOutputRange().getMax().intValue());
    this.colormapElements.add(last);
  }
  final LinearColorMapElement preservedValuesElement[]=new LinearColorMapElement[preservedValues.size()];
  final int value=(int)last.getOutputMaximum() + 1;
  for (int i=0; i < preservedValuesElement.length; i++) {
    preservedValuesElement[i]=LinearColorMapElement.create(org.geotools.resources.i18n.Vocabulary.format(org.geotools.resources.i18n.VocabularyKeys.NODATA) + Integer.toString(i + 1),preservedValuesColor,RangeFactory.create(preservedValues.get(i),preservedValues.get(i)),value);
  }
  this.colorMap=new LinearColorMap(name,(LinearColorMapElement[])colormapElements.toArray(new LinearColorMapElement[colormapElements.size()]),preservedValuesElement,this.gapsColor);
  return colorMap;
}
