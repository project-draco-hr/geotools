{
  if (clockwise(ordinates)) {
    for (int i=0; i < ordinates.length / 2; i++) {
      double temp=ordinates[i];
      ordinates[i]=ordinates[ordinates.length - i - 1];
      ordinates[ordinates.length - i - 1]=temp;
    }
  }
  double prevAngle=0;
  for (int i=0; i < ordinates.length; i+=2) {
    double x=ordinates[i];
    double y=ordinates[i + 1];
    double dx=x - cx;
    double dy=y - cy;
    double d=Math.sqrt(dx * dx + dy * dy);
    double distanceFromCircle=Math.abs(radius - d);
    if (distanceFromCircle > Circle.EPS) {
      fail("Found a point " + x + ","+ y+ " that's not on the circle with distance "+ distanceFromCircle+ " from it");
    }
    assertEquals(radius,d,Circle.EPS);
    double angle=atan2(dy,dx);
    if (i > 1) {
      double chordAngle=angle - prevAngle;
      if (chordAngle < 0) {
        chordAngle+=Math.PI * 2;
      }
 else       if (chordAngle > Math.PI) {
        chordAngle=Math.PI * 2 - chordAngle;
      }
      double halfChordLength=radius * Math.sin(chordAngle / 2);
      double apothem=Math.sqrt(radius * radius - halfChordLength * halfChordLength);
      double distance=radius - apothem;
      if (distance > tolerance) {
        fail("Max tolerance is " + tolerance + " but found a chord that is at "+ distance+ " from the circle");
      }
    }
    prevAngle=angle;
  }
}
