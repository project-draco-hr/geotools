{
  Tile.ensureNonNull("tiles",tiles);
  final Map<ReaderInputPair,List<Tile>> tilesByInput=new LinkedHashMap<ReaderInputPair,List<Tile>>(tiles.length + tiles.length / 4 + 1);
  providers=new FrequencySortedSet<ImageReaderSpi>(4,true);
  for (  final Tile tile : tiles) {
    tile.checkGeometryValidity();
    final ImageReaderSpi spi=tile.getImageReaderSpi();
    final ReaderInputPair key=new ReaderInputPair(spi,tile.getInput());
    List<Tile> sameInputs=tilesByInput.get(key);
    if (sameInputs == null) {
      sameInputs=new ArrayList<Tile>(1);
      tilesByInput.put(key,sameInputs);
      providers.add(spi);
    }
    sameInputs.add(tile);
  }
  providers=Collections.unmodifiableSet(providers);
  @SuppressWarnings("unchecked") final List<Tile>[] asArray=tilesByInput.values().toArray(new List[tilesByInput.size()]);
  final Comparator<List<Tile>> comparator=Comparators.forLists();
  Arrays.sort(asArray,comparator);
  int numTiles=0;
  for (  final List<Tile> sameInputs : asArray) {
switch (sameInputs.size()) {
case 0:
      throw new AssertionError();
case 1:
    break;
default :
  Collections.sort(sameInputs);
break;
}
for (final Tile tile : sameInputs) {
tiles[numTiles++]=tile;
}
}
this.tiles=tiles;
allTiles=UnmodifiableArrayList.wrap(tiles);
}
